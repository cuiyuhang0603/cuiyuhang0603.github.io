---
title: 回溯、动态规划、贪心
date: 2021-12-02 10:42:33
tags: 原文连接：https://blog.csdn.net/gui951753/article/details/104374621
---

# 概念描述

* 回溯法。回溯法被称为是万能的解法，几乎所有问题都可以用回溯法去解题。其核心思想就是枚举每一种情况，然后进行比较，最终得到最优解。这个算法的时间复杂度一般在指数级别O(2^n)。
* 动态规划。常用来求解可划分的问题。对于一个问题，它可以划分为由若干个子问题相互联系产生，那么就可以用动态规划来求解。
* 贪心。每次求得局部最优解，将局部最优解累加起来就变成了全局最优解。

<!-- more -->

* 问题。能够用动态规划和回溯法解答的题目都很有特点。一般来说就是多阶段，当前要求解的问题和其子问题有关，并且子问题的抉择影响到了后面的答案。如果当前问题规模记为f(n)的话，那么f(n)一定和f(n-1)或者f(n-2)有关系，可以是f(n)=f(n-1)+f(n-2)，也可以是f(n)=max/min(f(n-1)+1,f(n-2))等等。具体要看问题描述。

> 以上三个算法的基本概念，网上有更多资料，这里就不详细展开了。接下来讲我在学习过程中遭遇的问题。在实际运用这些算法解题的时候，经常会看到一些很奇怪的名词，比如解空间、自顶向下解法、自底向上解法等等。那么这些词到底代表的是什么含义呢？接下来通过一些具体的例子和图来展示。



# 斐波那契数列问题

## 问题描述

斐波那契数列是通过"递归"定义的，通过这个递归关系式，我们可以知道斐波那契数列中任意一个位置的数值。给你一个数字n，你能求出它对应的数列值是多少嘛？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220144103468.png)

## 回溯法

如果要求F(n)，那么必须要知道F（n-1）和F（n-2）。其问题就变成了求F(n-1)和F（n-2）。
举个例子，当我们计算f（7）的时候，必须要知道f(5)和f(6)，而计算f(5)又必须要知道f(3)和f(4)，直到问题规模缩小至f(0)和f(1)的时候，我们才能够根据已有的条件得到答案，然后往上回推。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220145021350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1aTk1MTc1Mw==,size_16,color_FFFFFF,t_70)

* **那么这个过程，就叫做自顶向下的分析过程。**
* **分析过程形成的树状图就叫做解空间。** 当我们从根节点扩展到叶子节点(**叶子节点是有解的最小问题**)的时候,就意味着我们从解空间找到了一个解。所以，只要构造好了解空间树，求解的过程就是**从根节点遍历到叶子节点的过程**。
* **整个分析阶段是不断把问题化解为子问题，直到子问题的规模有解的时候，再开始回推进行计算。**
* 使用回溯法存在的最主要问题就是存在大量重复计算，当计算f(7)的时候，需要计算f(5)和f(6)。而当计算f(6)的时候，需要再次计算下f(5)。

代码示意如下

~~~java
def f(n):
	if n==0:
		return 0
	if n==1:
		return 1
	return f(n-1)+f(n-2)
~~~

## 动态规划

使用回溯法解题的时候，习惯于把大问题分解，分解到问题规模可解的时候，再去解决问题。而动态规划则是从已知解出发，逐步推算到问题规模的程度。

* 回溯法。大问题————>分解为子问题————>子问题的规则足够小(可解)————>回推大问题。
* 动态规划。已知有解的子问题————>逐步推算到问题规模大小的大问题。

对于斐波那契数列问题而言，还拿f(7)举例，其过程如下：

* 已知解f(1)和f(2)。推算得到f(3)。
* f(3)+f(2)————》f(4)
* f(4)+f(3)————》f(5)
* f(5)+f(4)————》f(6)
* f(6)+f(5)————》f(7)

通过分析这个过程可以知道，动态规划的出发点是叶子节点，通过公式，逐步的从叶子结点上推到根节点。其核心思想就是**通过已知解，来求解未知解。直到求解到的问题规模符合题目要求的规模**

<img src="https://img-blog.csdnimg.cn/20200220150037999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1aTk1MTc1Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" />

**代码实现如下：**

~~~java
def f(n):
	// 定义一个长度为n+1的数组，用来存储和记录已经计算过的值
	a=[0]*(n+1)
	// 初始化已知解
	a[0]=0,a[1]=1
	// 利用公式进行递推，不断推导未知解，直到求出自己想要的未知解，停止。
	for i in range(2,n+1):
		a[i]=a[i-1]+a[i-2]
	return a[n]
~~~



## 总结

上文主要描述了解题的时候，回溯法和动态规划之间的区别。主要有以下几点。

* 回溯法。要实现回溯法解题，那么就要将问题规模进行切分，直到将问题切分到可解的时候再进行计算。
  * 时间复杂度O(2^n)。一般为指数级别，存在大量的重复计算，已经计算过的结果无法得到有效重用。
* 动态规划。从已知解推导问题，将问题推导到要求的未知解的规模即可。
  * 时间复杂度一般为遍历数组的复杂度。没有重复计算，会使用数组记录到之前已经计算出来的值。
* 如果遇到某些问题，问题分多个阶段，且当前阶段的结果会影响到后续的结果，那么这个问题就可以用回溯或者动态规划来求解。

