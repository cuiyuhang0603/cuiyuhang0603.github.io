---
title: 最大公共子序列
date: 2021-12-03 09:17:54
tags:
---

参考网址：https://blog.csdn.net/hrn1216/article/details/51534607

## 问题分析

子序列与子串不同，子序列允许中有间隔，所以若使用暴力解法，遍历所有可能性，时间复杂度非常高，一个长度为n的序列拥有2的n次方个子序列，它的时间复杂度是指数阶。
因此解决LCS，问题需要借助动态规划的思想。

<!-- more -->

## 思路简述

 假如S1的最后一个元素 与 S2的最后一个元素相等，那么S1和S2的LCS就等于 {S1减去最后一个元素} 与 {S2减去最后一个元素} 的 LCS  再加上 S1和S2相等的最后一个元素。

   假如S1的最后一个元素 与 S2的最后一个元素不等（本例子就是属于这种情况），那么S1和S2的LCS就等于 ： {S1减去最后一个元素} 与 S2 的LCS， {S2减去最后一个元素} 与 S1 的LCS 中的最大的那个序列。

## 递归公式

第3节说了LCS的特征，我们可以发现，假设我需要求 a1 ... am 和 b1 .. b(n-1)的LCS 和 a1 ... a(m-1) 和 b1 .. bn的LCS，一定会递归地并且重复地把如a1... a(m-1) 与 b1 ... b(n-1) 的 LCS 计算几次。所以我们需要一个数据结构来记录中间结果，避免重复计算。

假设我们用c[i,j]表示Xi 和 Yj 的LCS的长度（直接保存最长公共子序列的中间结果不现实，需要先借助LCS的长度）。其中X = {x1 ... xm}，Y ={y1...yn}，Xi = {x1 ... xi}，Yj={y1... yj}。可得递归公式如下：

![img](https://img-blog.csdn.net/20160529233036349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 构造LCS

​		本文S1和S2的最LCS并不是只有1个，本文并不是着重讲输出两个序列的所有LCS，只是介绍如何通过上表，输出其中一个LCS。
​		我们根据递归公式构建了上表，我们将从最后一个元素`c[8][9]`倒推出S1和S2的LCS。

1.`c[8][9] = 5`，且`S1[8] != S2[9]`，所以倒推回去，`c[8][9]`的值来源于`c[8][8]`的值(因为`c[8][8]` > `c[7][9]`)。

2.`c[8][8] = 5`,  且`S1[8] = S2[8]`, 所以倒推回去，`c[8][8]`的值来源于 `c[7][7]`。

   以此类推，如果遇到`S1[i] != S2[j]` ，且`c[i-1][j] = c[i][j-1]` 这种存在分支的情况，这里请都选择一个方向（之后遇到这样的情况，也选择相同的方向）。

## 代码实例

~~~java
public class LCSProblem
{
    public static void main(String[] args) {
        String[] x = {"","A","B","C","B","D","A","B"};
        String[] y = {"","B","D","C","A","B","A"};
        int[][] b = getLength(x,y);
        Display(b,x,x.length-1,y.length-1);
    }
    
    public static int[][] getLength(String[] x,String[] y) {
        int[][] b = new int[x.length][y.length];
        int[][] c = new int[x.length][y.length];
        
        for(int i=1;i<x.length;i++)
        {
            for(int j=1;j<y.length;j++)
            {
                if(x[i] == y[j]){
                    c[i][j] = c[i-1][j-1]+1;
                    b[i][j] = 1;
                } else if(c[i-1][j] >= c[i][j-1]){
                    c[i][j] = c[i-1][j];
                    b[i][j] = 0;
                } else {
                    c[i][j] = c[i][j-1];
                    b[i][j] = -1;
                }
            }
        }
        return b;
    }
    
    public static void Display(int[][] b,String[] x,int i,int j) {
        if(i == 0 || j == 0)  return;
        if(b[i][j] == 1) {
            Display(b,x,i-1,j-1);
            System.out.print(x[i] + "");
            
        } else if(b[i][j] == 0) {
            Display(b,x,i-1,j);
            
        } else if(b[i][j] == -1) {
            Display(b,x,i,j-1);
        }
    }
}
~~~

