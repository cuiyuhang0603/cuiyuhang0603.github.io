---
title: KMP算法
date: 2021-12-02 20:41:35
tags: 参考网址：https://www.cnblogs.com/dusf/p/kmp.html
---



# KMP算法

> 字符串匹配算法，常用于在主串中查找子串的问题，节省匹配时间

**思想：**利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。

**解释：**设遍历主串和子串，主串指针下标为i，子串下标为j，子串长度为len
相较于普通的匹配规则，对子串本身添加了一个参数，最大重复长度K
就是子串的`前缀集`和`后缀集`中相同的最大长度，

<!-- more -->

#### 举例：

字符串：`abc123abcd`
前缀集：{a,...,abc,...,abc123abc}
后缀集：{c,...,abc,...,bc123abcd}
最大重复串：`abc`	K=3	后缀重复下标起始位置为n

1. 当匹配数量大于0，且小于n时，
   子串下标重置为0，主串下标继续遍历。
2. 当匹配数量大于n，且小于等于`n+K-1`时，
   子串下标重置为`i-n`，主串下标继续遍历。



### 跳转状况：

1. 匹配重复字符串字段时，失败，则跳转到前缀的指定位置，
2. 否则从空开始。



## 核心代码

> 计算next数组，子串匹配失败时跳跃的下表位置

~~~java
public static int[] getNext(String ps) {
    char[] p = ps.toCharArray();
    int[] next = new int[p.length];
    next[0] = -1;
    int j = 0;
    int k = -1;
    while (j < p.length - 1) {
       if (k == -1 || p[j] == p[k]) {
           next[++j] = ++k;
       } else {
           k = next[k];
       }
    }
    return next;
}
~~~

代码理解的关键在于对子串模式的理解，除了重复子串外，皆无需顾虑才是KMP的核心。
减少了主字符串下标回溯时的开销。



