<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="月曜日的丰满">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="月曜日的丰满">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="方方">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>月曜日的丰满</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">月曜日的丰满</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/03/01-Java%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="方方">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月曜日的丰满">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/03/01-Java%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">01-Java笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-03 16:42:30 / 修改时间：18:10:34" itemprop="dateCreated datePublished" datetime="2021-11-03T16:42:30+08:00">2021-11-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaSE笔记"><a href="#JavaSE笔记" class="headerlink" title="JavaSE笔记"></a>JavaSE笔记</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.manongjc.com/article/77324.html">typora快捷键</a></p>
</li>
<li><p><a href="../%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.md">算法笔记</a></p>
</li>
</ul>
<p> Java学习路线图如下</p>
<ol>
<li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li>
<li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li>
<li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li>
<li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li>
</ol>
<h1 id="一、面向对象基础"><a href="#一、面向对象基础" class="headerlink" title="一、面向对象基础"></a>一、面向对象基础</h1><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8">方法</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#static">静态字段和静态方法</a></li>
<li>作用域</li>
<li>内部类</li>
<li><a href="#%E7%B1%BB%E8%B7%AF%E5%BE%84%E5%92%8Cjar%E5%8C%85">classpath和jar</a></li>
<li>模块</li>
</ul>
<h2 id="不同版本的Java"><a href="#不同版本的Java" class="headerlink" title="不同版本的Java"></a>不同版本的Java</h2><p><img src="img/image-20210815105533481.png" alt="image-20210815105533481"></p>
<ul>
<li><p>Java SE：标准版，包含标准的JVM和标准库</p>
</li>
<li><p>Java EE：企业版，在SE的基础上加上了大量的API和库</p>
<pre><code>            主要针对：web应用、数据库、消息服务等
</code></pre>
</li>
<li><p>Java ME：针对嵌入式设备的”瘦身版”，SE 标准库无法在ME上使用，ME的虚拟机也是”瘦身版”.</p>
</li>
</ul>
<h2 id="类路径和jar包"><a href="#类路径和jar包" class="headerlink" title="类路径和jar包"></a>类路径和jar包</h2><ul>
<li><p><strong>classpath的介绍：</strong></p>
<blockquote>
<p>classpath是jvm用到的一个环境变量，它用来指示JVM如何搜索class。<br>classpath就是一组目录的集合，它设置的搜索路径与操作系统有关。</p>
</blockquote>
</li>
<li><p><strong>classpath的设定方法：</strong></p>
<blockquote>
<p>1.在系统环境变量中设置classpath环境变量。<br>2.在启动JVM时设置classpath变量。</p>
<pre><code>（JVM默认的classpath为当前目录）
</code></pre>
<p>3.JVM不依赖classpath加载核心库</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>jar包的介绍：</strong></p>
<blockquote>
<p>如果项目中包含多个.class文件，散落在各层目录中，可以将目录打一个包，变成一个文件。<br>jar包的作用就是如此。</p>
</blockquote>
</li>
<li><p><strong>jar包的概念：</strong></p>
<blockquote>
<p>1.jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。<br>2.如果要执行一个jar包的class，就可以把jar包放到classpath中。<br>3.JVM会自动在hello.jar文件里去搜索某个类。</p>
</blockquote>
</li>
<li><p><strong>创建jar包：</strong></p>
<blockquote>
<ol>
<li>在资源管理器中，找到正确的目录，点击右键压缩文件夹，将.zip文件改为.jar文件即可。<br>（注意：jar包里的第一层目录，不能是bin）</li>
<li>可以配置/META-INF/MANIFEST.MF纯文本文件，可以指定Main-Class和其他信息。</li>
<li>3.jar包还可以包含其他jar包，需要在MANIFEST.MF文件里配置classpath。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>整数类型：byte，short，int，long</p>
</li>
<li><p>浮点数类型：float，double</p>
</li>
<li><p>字符类型：char</p>
</li>
<li><p>布尔类型：boolean</p>
<blockquote>
<p>Java是高精度强类型语言</p>
</blockquote>
</li>
</ul>
<h3 id="整型表示范围"><a href="#整型表示范围" class="headerlink" title="整型表示范围"></a>整型表示范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1B <span class="keyword">byte</span>:	-<span class="number">128</span> ~ <span class="number">127</span> </span><br><span class="line">2B <span class="keyword">short</span>: 	-<span class="number">32768</span> ~ <span class="number">32767</span> </span><br><span class="line">4B <span class="keyword">int</span>:	-<span class="number">2147483648</span> ~ <span class="number">2147483647</span> </span><br><span class="line">8B <span class="keyword">long</span>: 	-<span class="number">9223372036854775808</span> ~ <span class="number">9223372036854775807</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：Java中整型默认使用int进行计算</p>
</blockquote>
<h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p> 这个时候，如果想省略变量类型，可以使用<code>var</code>关键字：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：</p>
</blockquote>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型精度表：byte-short-(char)int-long-float-double</span></span><br><span class="line"><span class="comment">//1 自动类型转换情况1：  高精度变量=低精度数据</span></span><br><span class="line"><span class="comment">//2 自动类型转换情况2：	byte/short/char变量=int常量值</span></span><br><span class="line"><span class="comment">//3 强制类型转换：		 低精度变量=(低精度变量类型)高精度数据</span></span><br><span class="line"><span class="comment">//4	多类型运算结：		 运算后结果的数据类型取决于精度最高的数据</span></span><br></pre></td></tr></table></figure>



<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在java中，多维数组可以理解为，数组的元素是一个数组</span></span><br><span class="line"><span class="comment">所以可以使用下列方式声明不等宽的二维数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[N][];<span class="comment">//初始化二维数组时可以只写行数，而不写列数</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">int</span>[N-<span class="number">1</span>] = enw <span class="keyword">int</span>[K];</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">输入和输出</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF">分支和循环</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F&%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">基础排序</a></li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><p>Scanner</p>
<p>一个可以解析基本类型和字符串的简单文本扫描器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：System.in系统输入指的是通过键盘录入数据</p>
</blockquote>
<p>输入待解决问题：</p>
<blockquote>
<ol>
<li>Scanner调用Scanner中的hasNextInt()判断获取的输入是否为整型？</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p>System.out.printf</p>
<p>把数据显示成我们期望的格式，就需要使用格式化输出的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, d); <span class="comment">// 显示两位小数3.14</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%.4f\n&quot;</span>, d); <span class="comment">// 显示4位小数3.1416</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%Ns\n&quot;</span>,s);<span class="comment">//显示N长度的字符串，长度不够截取；长度不足，左对齐；加负号，右对齐。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：printf中似乎不可用字符串拼接。</p>
</blockquote>
<p>思考：</p>
<blockquote>
<ol>
<li>输出指定格式时不可使用字符串拼接？</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a>分支和循环</h3><ul>
<li><p>switch</p>
<blockquote>
<p>只适用于穷举法；不使用于范围判断</p>
</blockquote>
<ol>
<li>switch表达式的数据类型仅限于：int+String+enum</li>
<li>break的作用是 跳出switch结构</li>
<li>没有碰到break语句前，会一直执行分支的语句</li>
</ol>
</li>
<li><p>for</p>
<p>一般用于指定次数的循环。常用于遍历数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="comment">//循环指定语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：</p>
</blockquote>
</li>
<li><p>while</p>
<p>一般用于位置次数的循环，常用于逻辑判断结束循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件语句)&#123;</span><br><span class="line">   	<span class="comment">//循环指定语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>((n--)&gt;<span class="number">0</span>)&#123;&#125;<span class="comment">//循环n次</span></span><br><span class="line"><span class="keyword">while</span>((--n)&gt;<span class="number">0</span>)&#123;&#125;<span class="comment">//循环n-1次</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：</p>
</blockquote>
</li>
<li><p>break为跳出当前循环。</p>
</li>
<li><p>continue为跳过本次循环，进入下一次循环，循环体中，continue后面部分的内容就不执行了。</p>
</li>
</ul>
<h3 id="顺序排序-amp-冒泡排序"><a href="#顺序排序-amp-冒泡排序" class="headerlink" title="顺序排序&amp;冒泡排序"></a>顺序排序&amp;冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*冒泡排序</span></span><br><span class="line"><span class="comment">思想：每次选出无序元素中的最值，排到无序元素序列的队尾，</span></span><br><span class="line"><span class="comment">实现：已经排到队尾的元素为有序元素，后续可以不用遍历，第i次遍历a.length-i-1次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//共arr.length-1行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;<span class="comment">//让arr[j]作为前面的元素 arr[j+1]是后面的元素</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> k=arr[j];arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序排序</span></span><br><span class="line"><span class="comment">思想：每次取当前位置的元素与后续所有元素比较，选出最值放入当前位置。</span></span><br><span class="line"><span class="comment">实现：从i+1开始遍历，a.length-1结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//共arr.length-1行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;<span class="comment">//arr[i]作为当前元素 arr[j]作为当前元素后面的元素</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;arr[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> k=arr[j];arr[j]=arr[i];arr[i]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 思想：从前往后遍历数组，但是从后向前进行比较</span></span><br><span class="line"><span class="comment"> * 实现：将第i各元素，倒着和前面的元素比较和挪移，最后放入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];<span class="comment">//保存当前元素</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];<span class="comment">//将元素向后挪移</span></span><br><span class="line">            &#125;&#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;<span class="comment">//将元素插入</span></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote>
<p>概念：方法自己调用自己<br>注意事项：</p>
<ol>
<li>方法递归必须有出口；</li>
</ol>
</blockquote>
<ul>
<li>斐波那契数列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        System.out.print(Shu(i)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Shu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Shu(n-<span class="number">2</span>) + Shu(n-<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>







<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><blockquote>
<p>修饰符：让被修饰者具有一些本来不具有的特征的关键字</p>
<p>修饰符分类：范围修饰符  静态修饰符 常量修饰符 <strong>同步修饰符</strong></p>
</blockquote>
<ul>
<li>范围修饰符</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>本类</th>
<th>本包</th>
<th>子类</th>
<th>非包</th>
<th>范围总结</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>整个项目</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>本包及其他包子类</td>
</tr>
<tr>
<td>默认范围</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>本包</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>本类</td>
</tr>
</tbody></table>
<blockquote>
<p>注：由该类创建出的对象，在该类中可以直接获取类中的私有属性。</p>
</blockquote>
<ul>
<li><p>final</p>
<ul>
<li>修饰字段值：常量，一旦赋值不可更改、没有默认初始值。</li>
<li>修饰方法：不可被重写。</li>
<li>修饰类：类不可被继承。</li>
<li>修饰引用变量，表示引用不可变，但是引用的内容可变。</li>
<li>被final修饰的方法，JVM会尝试将其内联，以提高运行效率。</li>
<li>被final修饰的常量，会在编译阶段会存入常量池。</li>
</ul>
<blockquote>
<p>从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略</p>
</blockquote>
</li>
</ul>
<ul>
<li>static(静态)<ul>
<li>特点：<ol>
<li>使用静态修饰的成员不会随对象变化。</li>
<li>修饰的成员属于类，所有对象共享使用。</li>
</ol>
</li>
<li>静态方法：<ol>
<li>可以不用实例化，直接调用方法。</li>
<li>可以访问静态成员，不可以访问非静态成员。</li>
<li>静态方法中不能使用this关键字。</li>
</ol>
</li>
<li>静态代码块<ol>
<li>当第一次用到本类时，静态代码块执行唯一的一次。</li>
<li>一般用于类中静态成员的初始值。</li>
</ol>
</li>
<li><strong>修饰类(静态类)：</strong><ol>
<li>全局唯一，任何一次的修改都是全局的影响。</li>
<li><strong>只加载一次，优先于非静态。</strong>？？？？</li>
<li>生命周期属于类级别，从JVM加载开始到JVM御载结束。</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>abstract(抽象)</p>
<ul>
<li><p>修饰对象：类、方法</p>
</li>
<li><p>修饰效果：</p>
<ol>
<li><p>抽象方法不能有方法体</p>
</li>
<li><p>抽象方法的类必须是抽象类</p>
</li>
<li><p><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a>不能创建对象 但是可以定义引用</p>
</li>
<li><p>子类继承抽象类 必须实现所有抽象方法</p>
<pre><code>或者 定义为抽象类
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote>
<p> 方法是一个实现特定功能的代码块，又名函数。<br> 方法的作用：代码的复用<br> 方法的本质：就是一个功能</p>
</blockquote>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用方法传递参数时，根据传递类型不同，会产生不同的效果，为了方便理解，</span></span><br><span class="line"><span class="comment">可以将参数传递等效为代码操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a)</span></span>;<span class="comment">//等效代码：int a = N;</span></span><br><span class="line"><span class="comment">//当a发生改变时，不会影响到N的值。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] arry)</span></span>;<span class="comment">//等效代码：int[] arry = Arry[];</span></span><br><span class="line"><span class="comment">//因为arry和Arry指向同一片地址，所以对地址的数据进行修改时，会影响到双方。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	str = <span class="keyword">new</span> String();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当在方法中调用了new操作时，会将传递的参数引用地址覆盖，</span></span><br><span class="line"><span class="comment">所以不会影响到原地址值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不定参数(JDK1.8的新特性)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>... a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">double</span> d,<span class="keyword">int</span>... a)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.使用(类型... 名称)传递不确定个数的某一类型变量。</span></span><br><span class="line"><span class="comment">2.参数接收后，会自动封装为一个数组。</span></span><br><span class="line"><span class="comment">3.当多个类型参数并列时，将此格式放在最后</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span>的作用：<span class="number">1</span> 把方法的返回值返回给调用者  <span class="number">2</span> 结束方法</span><br></pre></td></tr></table></figure>



<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul>
<li><p>特点</p>
<blockquote>
<p>1 必须是同一个类<br>2 方法名必须相同<br>3 方法参数列表必须不同：</p>
<pre><code>参数个数不同，参数类型不同，参数顺序不同
</code></pre>
</blockquote>
</li>
<li><p>使用场景</p>
<blockquote>
<p>几个功能一致，只是参数列表不同；<br>功能基本一致，满足不同参数列表的需求；</p>
</blockquote>
</li>
</ul>
<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类可以看做是对象的模板，通过类这个模板，可以创建出无数个对象。<br>类中拥有的字段值和方法，对象都可以访问。</p>
<ul>
<li><p>类中包括的内容：</p>
<ol>
<li><p>成员变量——实例化对象可以使用，类不可使用。</p>
</li>
<li><p>成员方法——实例化对象调用，类不可调用。</p>
</li>
<li><p>静态字段——类可以调用，无序实例化。</p>
</li>
<li><p>静态方法——类可以调用，无需实例化对象。</p>
<blockquote>
<p>如果一个方法没有涉及实例，尽量成静态方法</p>
</blockquote>
</li>
<li><p>内部类</p>
</li>
<li><p>代码块</p>
<ul>
<li>构造代码块：一般用于给对象的实例变量初始化</li>
<li>静态代码块：只有在类加载时执行一次，一般用于给类变量初始化</li>
</ul>
</li>
</ol>
</li>
<li><p>成员变量和局部变量</p>
<ul>
<li>概念解释：</li>
<li>相同之处：</li>
<li>不同之处：<ol>
<li>作用域不同：前者在对象中，后者在方法中。</li>
<li>默认值：前者有默认值，后者需显式赋值。</li>
<li>修饰符：<ul>
<li>前者：范围修饰    静态修饰  final修饰</li>
<li>后者： final修饰</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>构造方法/构造器</p>
<ul>
<li>构造方法没有返回值，不用void标识</li>
<li>构造方法不能被对象调用</li>
</ul>
</li>
</ul>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ol>
<li><p><strong>加载类；</strong></p>
<blockquote>
<p>为类创建静态区域，用来记载类的静态成员<br>执行静态代码块、为静态变量赋值等操作。</p>
</blockquote>
</li>
<li><p>定义引用；</p>
</li>
<li><p><strong>创建对象：new调用构造器：</strong></p>
<ol>
<li><p>内存中划分区域，创建对象。</p>
</li>
<li><p>调用父类构造器，将父类的实例成员加载进子类对象的内存中。</p>
<blockquote>
<p>1.构造方法不能加载进对象内存中；<br>2.创建对象时只加载普通方法的方法声明，不加载方法体：调用时才加载</p>
</blockquote>
</li>
<li><p>执行调用的父类构造器中的语句。</p>
</li>
<li><p>调用子类构造器，将子类的实例成员加载进子类对象内存中。</p>
</li>
<li><p><strong>隐藏子类对象从父类继承但被重新定义的成员。</strong></p>
</li>
<li><p>执行子类构造器中的语句。</p>
</li>
</ol>
</li>
<li><p>让引用指向此对象</p>
</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用<a href="#abstract(%E6%8A%BD%E8%B1%A1)">abstract</a>关键字修饰的类</p>
<ul>
<li>抽象类有构造方法，不是用来创建本类对象，是用来帮助创建子类对象的。</li>
<li>抽象类中可以没有抽象方法。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用Interface关键字声明，与class同级</p>
<ul>
<li><p>概念：内部全是抽象方法的<a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></p>
<blockquote>
<p>接口和类不是同一种形态</p>
</blockquote>
</li>
<li><p>作用：</p>
<ol>
<li>增加程序的扩展性</li>
<li>提高代码的复用性</li>
<li>降低模块之间的耦合度</li>
</ol>
</li>
<li><p>特点：</p>
<ul>
<li>成员变量默认修饰符：public static final</li>
<li>没有构造方法，不能创建对象，但是可以引用对象</li>
<li>支持多继承，不影响继承直接父类</li>
</ul>
</li>
<li><p>使用：implements关键字</p>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><p>作用：</p>
<ol>
<li>使外部代码可控制的访问内部的代码。</li>
<li>解耦：外部调用不需要知道内部的实现，只提供内部所需的数据等。</li>
</ol>
</li>
<li><p>实现：</p>
<blockquote>
<p>使用<a href="#%E8%8C%83%E5%9B%B4%E4%BF%AE%E9%A5%B0%E7%AC%A6">范围修饰符</a>限制成员的可见性，设置外部访问的方法接口。<br>一般使用private关键字，限制只能本类访问</p>
</blockquote>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p><strong>特点</strong></p>
<ul>
<li><p>子类可以继承父类中的所有实例成员</p>
</li>
<li><p>子类不能继承父类的构造方法</p>
</li>
<li><p>子类可以重新定义父类已有的成员(包括变量和方法)</p>
</li>
<li><p>Java支持单继承，一个子类只能有一个直接父类，</p>
<p>但是可以继承多个<a href="#%E6%8E%A5%E5%8F%A3">接口</a></p>
</li>
<li><p>所有类默认继承自<a href="#Object%E7%B1%BB">Object类</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>重名问题</strong><a href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">(向上转型)</a></p>
<ul>
<li><p>变量重名</p>
<ol>
<li>直接通过子类对象访问成员变量：<pre><code>等号左边是谁，就优先用谁，没有则向上找。
</code></pre>
</li>
<li>间接通过成员方法访问成员变量：<pre><code>该方法属于谁，就优先用谁，没有则向上找。
</code></pre>
</li>
</ol>
</li>
<li><p>方法重名</p>
<ol>
<li><p>创建的对象是谁，就优先用谁，如果没有则向上找</p>
<blockquote>
<p>局部变量：直接用变量名称<br>本类变量：<code>this.变量名称</code><br>父类变量：<code>super.变量名称</code> </p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>super</code></p>
<ol>
<li>子类构造方法会默认使用<code>super()</code>调用父类无参构造(隐式)</li>
<li>若父类没有无参构造，则需要显式调用有参构造<code>super(参数列表)</code></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>方法重写</strong></p>
<blockquote>
<p>使用new创建的是哪个对象，实际执行时，就调用哪个对象的方法。<br>(多态)</p>
</blockquote>
<ul>
<li>子类方法的返回值必须小于等于父类方法的返回值范围</li>
<li>子类方法的权限必须大于等于父类方法的权限修饰符</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>概念：相同类型的对象，调用同一方法(参数列表也相同，区别方法重载)，在实际运行时，可能会执行出不同的结果。</li>
<li>实现：<ul>
<li>前提前提条件是继承、重写、<a href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">向上转型</a></li>
</ul>
</li>
<li>特点：<a href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">多态特点</a></li>
<li>应用：<ol>
<li>参数列表类型：传递子类</li>
<li>成员变量类型：赋值子类</li>
<li>返回值类型：返回子类</li>
<li>数组元素类型：存入多种子类对象</li>
</ol>
</li>
</ul>
<ul>
<li><p>向上转型</p>
<blockquote>
<p>定义父类引用指向创建的子类对象。</p>
<p>特点：除了重写的方法，其他的和父类对象完全一致</p>
<p>参考：<a href="#%E7%BB%A7%E6%89%BF">重名问题</a></p>
</blockquote>
</li>
<li><p>向下转型</p>
<blockquote>
<p>使用InstanceOf判断转型是否可以成功</p>
</blockquote>
</li>
</ul>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ul>
<li>Arrays</li>
<li><a href="#Calendar%E7%B1%BB">Calendar</a></li>
<li><a href="#Date%E7%B1%BB">Date</a></li>
<li>Math</li>
<li>Object</li>
<li>System</li>
<li>String</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学习类：</span><br><span class="line">   1  此类作用</span><br><span class="line">   2  此类常用的方法</span><br><span class="line">   3  此类相关的面试题和练习</span><br></pre></td></tr></table></figure>



<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(n1,n2)</span></span>;<span class="comment">//返回n1的n2次方</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> E <span class="title">max</span><span class="params">(E n1,E n2)</span></span>;<span class="comment">//返回最大值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> PI = 精度范围内的圆周率;<span class="comment">//Math.PI</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> E = 比任何其他值都更接近 e（即自然对数的底数）的 <span class="keyword">double</span> 值。;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求近似值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> num)</span></span>;<span class="comment">//向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> num)</span></span>;<span class="comment">//向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> num)</span></span>;<span class="comment">//四舍五入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求次方</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cbrt</span><span class="params">(<span class="keyword">double</span> a)</span></span>;<span class="comment">//开三次方</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span></span>;<span class="comment">//开二次方</span></span><br></pre></td></tr></table></figure>

<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span>    			:启动垃圾回收器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span>  	:虚拟机退出：参数为0正常退出 非0异常退出</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> :获取当前时间的毫秒值：参照历元<span class="params">(<span class="number">1970</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>;<span class="comment">//按比较器c对数组a进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(数组)</span></span>;<span class="comment">//按照默认升序（从小到大）对数组的元素进行排序</span></span><br><span class="line"><span class="comment">//自定义类型需要实现Comparable或这Comparator接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span>;			<span class="comment">//由参数数组获取一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(booleanp[] a)</span></span>;		<span class="comment">//获取参数数组的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">deepToString</span><span class="params">(Object[] a)</span></span>;		<span class="comment">//打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(booleanp[] a,<span class="keyword">boolean</span> val)</span></span>;	<span class="comment">//使用val填充数组a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a,Object b)</span></span>;</span><br><span class="line"><span class="comment">/*一般用来比较引用类型变量</span></span><br><span class="line"><span class="comment">1.如果参数彼此相等，则返回true，否则返回false。</span></span><br><span class="line"><span class="comment">2.如果两个参数都为null，则返回true。</span></span><br><span class="line"><span class="comment">3.如果第一个参数不为null，则通过使用此方法的第二个参数调用第一个参数的equals方法来确定相等性。否则，返回false。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span></span>;</span><br><span class="line"><span class="comment">/*用来计算多个对象关联的哈希值*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span>;</span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	1.列表中的所有元素必须实现Comparable接口，</span></span><br><span class="line"><span class="comment">	1.该方法是对传入list直接进行排序，而不是返回一个新的有序list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list,T obj)</span></span>;	<span class="comment">//使用参数对象obj替换list中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> T <span class="title">max</span><span class="params">(Collection coll)</span></span>;		<span class="comment">//获取最大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> T <span class="title">min</span><span class="params">(COllection coll)</span></span>;		<span class="comment">//获取最小的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> T <span class="title">max</span><span class="params">(Collection coll,Comparator comp)</span></span>;	<span class="comment">//按指定比较器 获取最大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> T <span class="title">min</span><span class="params">(Collection coll,Comparator comp)</span></span>;	<span class="comment">//按指定比较器 获取最小元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span></span>;	<span class="comment">//反转集合</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span>;	<span class="comment">//随机洗牌</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span>;		<span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>;<span class="comment">//按参数比较器 排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;<span class="comment">//下标i和下标j处的元素互换位置</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：区别Collection和Collections</p>
</blockquote>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul>
<li><p><strong>字符串的特点</strong></p>
<ol>
<li>字符串的内容永不可变</li>
<li>正是因为字符串不可改变，所以字符串是可以共享使用的</li>
<li>字符串效果上相当于是cahr[]字符数组，但是底层原理是byte[]字节数组</li>
</ol>
</li>
<li><p><strong>字符串常用创建方式：</strong></p>
<img src="img/image-20210821163901908.png" alt="image-20210821163901908" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;<span class="comment">//&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>;<span class="comment">//根据字符数组创建字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span>;<span class="comment">//根据字节数组创建对应字符串</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>java1.7后，增加了字符串常量池，用于存放不使用new关键字创建的String，池中的字符串可以被多个字符串变量“指向”。</li>
<li>使用new关键字创建的字符串不在字符串常量池中，会在额外创建一个新的字符串，即使两个字符串内容相同。</li>
</ol>
</blockquote>
</li>
<li><p>String的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;<span class="comment">//获取字符串中含有的字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span></span>;<span class="comment">//将当前字符串拼接成为新字符串，并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//获取指定索引位置的单个字符（索引从0开始）</span></span><br><span class="line"><span class="comment">//查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;<span class="comment">//查找最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;<span class="comment">//判断是否包含指定的子串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>;<span class="comment">//比较字符串大小，大则正数，相等0，小则负数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;<span class="comment">//忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串截取*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>; </span><br><span class="line"><span class="comment">//[begin,end),包含左，不包含右边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes();<span class="comment">//返回字符串底层的字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName);<span class="comment">//使用指定编码集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray();<span class="comment">//返回字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence oldString,CharSequence newString)</span></span>;</span><br><span class="line"><span class="comment">//将字符串中的对应字段替换为新的字段，并返回替换完后的新的字符串。</span></span><br><span class="line"><span class="comment">//可以替换多次出现的字段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex);<span class="comment">//按照参数的规则将字符串切割成为若干部分</span></span><br><span class="line"><span class="comment">/* 字符串切割：</span></span><br><span class="line"><span class="comment"> 如果开头或者中间是连续多个“刀”，会形成多个空字符串</span></span><br><span class="line"><span class="comment"> 但如以多个连续“刀”结尾不会形成空字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：regex是一个<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>，使用特殊符号时，需要加上转义字符<br>例：”\.”,表示使用.来切割字符串</p>
</blockquote>
</li>
</ul>
<ul>
<li>String的版本特性</li>
</ul>
<p> 从<strong>Java 13</strong>开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：String为引用类型</p>
</blockquote>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p><img src="img/CFfhEibtAsv9y4e.png" alt="image-20210830113134156"></p>
<ul>
<li>equals</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>euqals方法编写的规则</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
</blockquote>
<ul>
<li>hashCode</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;<span class="comment">//返回一个hash值，每次运行可能不一样</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：</p>
</blockquote>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>enum定义的类型就是class</p>
<ul>
<li><strong>特点：</strong><ul>
<li>定义的enum类型总是继承自java.lang.Enum，且无法被继承；</li>
<li>只能定义出enum的实例，而无法通过new操作符创建enum的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将enum类型用于switch语句。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(</span><br><span class="line">            Month.JAN.name()+<span class="string">&quot;:&quot;</span><span class="comment">//输出实例名称</span></span><br><span class="line">            +Month.JAN.dayValue+<span class="string">&quot;:&quot;</span><span class="comment">//输出实例的属性</span></span><br><span class="line">            +Month.JAN.ordinal());<span class="comment">//输出实例的序号0~n，会随顺序改变</span></span><br><span class="line">		<span class="comment">//输出结果  JAN:31:0</span></span><br><span class="line">	&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span></span>&#123;</span><br><span class="line">	JAN(<span class="number">31</span>),FEB(<span class="number">28</span>);<span class="comment">//枚举类实例</span></span><br><span class="line">    <span class="comment">//实例的属性,一般声明为final类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">	<span class="comment">//私有构造方法，外部不可调用</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>byte</th>
<th>short</th>
<th>int *</th>
<th>long</th>
<th>double</th>
<th>float</th>
<th>char*</th>
<th>boolean</th>
</tr>
</thead>
<tbody><tr>
<td>包装类型</td>
<td>Byte</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Double</td>
<td>Float</td>
<td>Character</td>
<td>Boolean</td>
</tr>
</tbody></table>
<ol>
<li><p>包装类解决的问题：包装类对象、字符串、基本数据类型常量之间的相互转换</p>
</li>
<li><blockquote>
<p>从JDK 1.5+开始，支持自动装箱、自动拆箱。</p>
<p>自动装箱：基本类型–&gt;包装类型<br>自动拆箱：包装类型–&gt;基本类型 </p>
</blockquote>
</li>
</ol>
<ul>
<li><p>类型最值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">包装类.MAX_VALUES;<span class="comment">//获取类型最大值</span></span><br><span class="line">包装类.MIN_VALUES;<span class="comment">//获取类型最小值</span></span><br><span class="line"><span class="comment">//具体操作如下：</span></span><br><span class="line"><span class="keyword">int</span> Max = Integer.MAX_VALUES;</span><br><span class="line"><span class="keyword">int</span> Min = Integer.MIN_VALUES;</span><br></pre></td></tr></table></figure></li>
<li><p>Integer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span></span>;<span class="comment">//基本数据转包装</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span>;<span class="comment">//字符串转包装,异常NumberFormatException</span></span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;<span class="comment">//包装转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,*<span class="keyword">int</span> radix)</span></span>;<span class="comment">//可以指定进制，也可以不指定</span></span><br><span class="line"><span class="comment">/*parse方法为大多数包装类的类型转换方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> value)</span></span>;<span class="comment">//基本数据转包装，[-128,127]指向常量池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(String s)</span></span>;<span class="comment">//字符串转包装</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span>;<span class="comment">//使用指定的进制radix解析字符串s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//2进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//16进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toOctalString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//8进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,*<span class="keyword">int</span> radix)</span></span>;<span class="comment">//指定进制的字符串</span></span><br></pre></td></tr></table></figure></li>
<li><p>character</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Character中的特有方法  一般用于判断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//判断是否是数字字符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//判断是否是(字母/汉字)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetterOrDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;<span class="comment">//判断是否是上述两者</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowerCase</span><span class="params">(<span class="keyword">char</span> c)</span></span>;<span class="comment">//判断是否是小写字母</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUpperCase</span><span class="params">(<span class="keyword">char</span> c)</span></span>;<span class="comment">//判断是否是小写字母</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> c)</span></span>;<span class="comment">//获取参数字符小写</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">toUpperCaser</span><span class="params">(<span class="keyword">char</span> c)</span></span>;<span class="comment">//获取参数字符大写</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进阶类"><a href="#进阶类" class="headerlink" title="进阶类"></a>进阶类</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/79f6d2aca1d8">参考网站</a></p>
<blockquote>
<p>概念：定义在类内部的类</p>
<p>好处：</p>
<ol>
<li>内部类的继承关系不受外部类影响;</li>
<li>成员内部类可以无条件访问外部类的所有属性;</li>
</ol>
</blockquote>
<ul>
<li><p>成员内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1. 可以无条件的访问外部类的属性和方法;</span><br><span class="line">2. 但是外部类想要访问内部类，必须要创建一个内部类对象，然后通过对象访问内部类;</span><br><span class="line">	内部类想要创建对象，必须实例化一个外部类对象;</span><br><span class="line">3. 不能包含静态属性或方法;</span><br><span class="line"></span><br><span class="line">访问权限：</span><br><span class="line">private:仅外部类可访问;</span><br><span class="line">protected:同包下或继承类可访问;</span><br><span class="line">default:同包下可访问;</span><br><span class="line">public:所有类可访问;</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line">1. 创建内部类</span><br><span class="line"> 	内部类寄身于外部类，创建内部类对象就必须先创建外部类对象;</span><br><span class="line">	 外部类名.内部类名 name = 外部对象.new 内部类(参数列表);</span><br><span class="line">2. 内部类调用外部类</span><br><span class="line">	若同名，则 外部类名.this.属性/方法名 调用外部类的成员;</span><br></pre></td></tr></table></figure></li>
<li><p>局部内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特点:</span><br><span class="line">1. 局部类和局部变量类似，不能使用范围权限修饰符和 static;</span><br><span class="line">2. 作用域仅限于方法内部;</span><br><span class="line">3. 不能包含静态属性或方法;</span><br><span class="line">4. 只能访问所属方法的final变量; 和声生命期有关</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line">1. 在作用域中基本随意使用;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dearcabbage/p/10609838.html">匿名内部类</a>(最常用，Lambda表达式有关)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">特点:</span><br><span class="line">1. 没有构造方法;</span><br><span class="line">2. 只能访问外部类的final变量;</span><br><span class="line">3. 只能使用唯一一次,一般用于创建对象，或传参;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">1. 在方法参数处直接使用new创建类;</span><br><span class="line"></span><br><span class="line">接口名称 name = new 接口名称&#123;方法体&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1. 只能调用外部类的静态属性或方法;</span><br><span class="line">2. 不依赖外部类，可以不用外部类对象实例创建对象;</span><br><span class="line"></span><br><span class="line">使用：</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String：字符串常量，字符序列不能更改</span><br><span class="line">StringBuffered和StringBuilder：字符串缓冲区，字符序列可以更改</span><br><span class="line">相同之处：都可描述字符串</span><br><span class="line">不同之处：String，自付出啊常量 字符串对象一旦床架 字符序列不能更改</span><br><span class="line">		StringBuffer和StringBuilder，都是字符串缓冲区，字符串长度和字符序列都可以更改</span><br><span class="line">		StringBuffer和StringBuilder都是字符串缓冲区 API兼容(方法完全相同)</span><br><span class="line">		版本不同：StringBuilder <span class="number">1.5</span> StringBuffer <span class="number">1.0</span></span><br><span class="line">		是否同步：StringBuilder线程不同步，只支持单线程，线程不安全效率高</span><br><span class="line">				StringBuffer线程同步，支持多线程，线程安全，效率低</span><br><span class="line">		</span><br><span class="line">	以StringBuffer为例：</span><br><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">	StringBuffer():<span class="comment">//创建一个初始序列为空的字符串缓冲区对象</span></span><br><span class="line">	StringBuffer(String str):<span class="comment">//创建一个与初始字符串相同序列的字符串缓冲区对象</span></span><br><span class="line"><span class="comment">//普通方法(特有方法)：</span></span><br><span class="line">	<span class="function">StringBuffer <span class="title">append</span><span class="params">(Object obj)</span>:<span class="comment">//把参数对象对应的字符串添加到末尾</span></span></span><br><span class="line"><span class="function">	StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:<span class="comment">//删除start到end-1处的字符</span></span></span><br><span class="line"><span class="function">	StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span>:<span class="comment">//删除index下标处的字符</span></span></span><br><span class="line"><span class="function">	StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,Object obj)</span>:<span class="comment">//把obj对应的字符串插入到offset下标处</span></span></span><br><span class="line"><span class="function">	StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span>:<span class="comment">//使用str替换start到end-1位置处的子串</span></span></span><br><span class="line"><span class="function">	StringBuffer <span class="title">reverse</span><span class="params">()</span>:<span class="comment">//字符串倒序排列</span></span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">char</span> ch)</span>:<span class="comment">//设置index下标处的字符为ch</span></span></span><br><span class="line"><span class="function">	String <span class="title">toString</span><span class="params">()</span>:<span class="comment">//获取当前字符串缓冲区相同序列的字符串对象	</span></span></span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li><p>Random类</p>
<ol>
<li>用来创建伪随机数。根据指定的初始种子，产生的随机数列是完全一样的。</li>
<li>如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，得到的伪随机数列就不同。</li>
</ol>
</li>
<li><p>SecureRandom类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程安全的随机数。</span></span><br><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">   System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。</p>
</li>
</ul>
<h1 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//概念：用于描述程序运行出现非正常情况的一组类a</span></span><br><span class="line"><span class="comment">//throws和throw的区别</span></span><br><span class="line"><span class="comment">//相同之处</span></span><br><span class="line">都是异常处理的关键字</span><br><span class="line"><span class="comment">//不同之处</span></span><br><span class="line"><span class="number">1</span> 位置不同：<span class="keyword">throws</span>用在方法声明上 <span class="keyword">throw</span>用在方体中</span><br><span class="line"><span class="number">2</span> 后面跟的内容不同：<span class="keyword">throws</span>后面跟多个异常类型 <span class="keyword">throw</span>后面跟一个异常</span><br><span class="line"><span class="number">3</span> 作用不同：<span class="keyword">throws</span> 用在方法声明上 来表示当前方法可能产生哪些异常 </span><br><span class="line">					一旦产生这些异常 异常会被封装为对象 抛给调用者</span><br><span class="line">		   <span class="keyword">throw</span> 用在方法体中 表示程序出现指定的异常</span><br></pre></td></tr></table></figure>



<h2 id="异常实例"><a href="#异常实例" class="headerlink" title="异常实例"></a>异常实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassCastException					: 向下转型时：容易出现的异常;</span><br><span class="line">NullPointerException				: 空指针异常;</span><br><span class="line">StringIndexOutOfBoundsException		: 字符串下标越界异常;</span><br><span class="line">ArrayIndexOutOfBoundsException		: 数组下标越界异常;</span><br><span class="line">IndexOutOfBoundsException			: 集合下标越界异常;</span><br><span class="line">ArithmeticException					: 算术逻辑异常;</span><br><span class="line">ParseException						: 字符串格式转换异常;</span><br><span class="line">ClassCastException					: 类型转换异常;</span><br><span class="line">NumberFormatException				: 数据输入格式异常;</span><br><span class="line">UnsupportedEncodingException		: 编码集名称异常;</span><br><span class="line">ConcurrentModificationException		: 并发修改异常;</span><br></pre></td></tr></table></figure>



<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><img src="img/image-20210816115949877.png" alt="image-20210816115949877" style="zoom: 50%;" />

<ul>
<li><p>Throwable是异常体系的根，他有两个体系：</p>
<ol>
<li><p>Error：严重的错误，通过java代码逻辑<strong>不能处理</strong>的严重错误。</p>
</li>
<li><p>Exception：则是运行时的错误，它可以被<strong>捕获并处理</strong>。 </p>
</li>
</ol>
</li>
<li><p>Exception两大分支：</p>
<ol>
<li>RuntimeException，以及他的子类：<br>运行时异常，未检查异常。<br>出现频率高，编译器不检查，默认抛出，可以不用处理。</li>
<li>非RuntimeException（包括IOException等等）：非运行时异常<br>已检查异常，编译时异常。<br>出现频率低，编译器检查，在代码中必须显示处理。</li>
</ol>
</li>
<li><p>异常体系特点</p>
<ol>
<li>异常类都必须直接或间接的继承Throwable类</li>
<li>子类都是以父类名字为后缀</li>
<li>异常的子类 常用方法都继承与Throwable类<br>区别是类名和异常原因</li>
</ol>
</li>
<li><p>Throwable常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Throwable();<span class="comment">//构造一个将 null 作为其详细消息的新 throwable。</span></span><br><span class="line">Throwable(String message);<span class="comment">//构造带指定详细消息的新 throwable。</span></span><br><span class="line">Throwable(String messagem,Throwable throwable);<span class="comment">//创建详细信息和原因的异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;<span class="comment">//获取详细信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;<span class="comment">//返回异常类型：详细信息</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抛出机制</span><br><span class="line">在方法声明上加throw PareException 作用</span><br><span class="line">1 当前方法可能出现异常：ParseException</span><br><span class="line">2 如果当前方法出现异常ParseException 异常对象被抛给方法的调用者 去处理</span><br></pre></td></tr></table></figure></li>
<li><p>捕获异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 若 <span class="keyword">try</span> 代码块出现异常 <span class="keyword">try</span>中的其他代码块不再执行 </span><br><span class="line">    而是执行对应的<span class="keyword">catch</span>代码块;</span><br><span class="line"><span class="number">2.</span> 捕获父类异常的 <span class="keyword">catch</span> 代码块 必须放在捕获子类异常 <span class="keyword">catch</span> 代码块的后面;</span><br><span class="line"><span class="number">3.</span> 如果在 <span class="keyword">try</span> 或者 <span class="keyword">catch</span> 代码块中 停止虚拟机 <span class="keyword">finally</span> 代码块将不再执行;</span><br><span class="line"></span><br><span class="line">重点: 关于 <span class="keyword">return</span> 的理解：<span class="keyword">return</span>执行分为两步，返回值，结束方法;</span><br><span class="line">	<span class="keyword">return</span> 一旦被调用后，就会将值返回，执行完<span class="keyword">finally</span>语句后再结束方法;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><blockquote>
<p>根据项目需求 定义jre中没有的异常</p>
<p>注意事项：1 异常类必须直接或者间接继承Throwable</p>
<pre><code>                2 异常类之间的区别：异常类名+异常原因(通过构造方法的参数列表)
</code></pre>
</blockquote>
<h2 id="日志打印异常"><a href="#日志打印异常" class="headerlink" title="日志打印异常"></a>日志打印异常</h2><p>使用日志的目的是为了更好的记录程序运行中的信息，包括但不限于：<br>程序的执行步骤、程序触发的异常等信息，使用日志可以将以上信息以规范的格式进行输出，便于阅读查看，同时，省去了部分代码的设计。</p>
<h3 id="Commons-Logging的使用"><a href="#Commons-Logging的使用" class="headerlink" title="Commons Logging的使用"></a>Commons Logging的使用</h3><blockquote>
<p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。</p>
</blockquote>
<p><strong>Commons Logging定义了6个日志级别：</strong></p>
<blockquote>
<ul>
<li><p>FATAL</p>
</li>
<li><p>ERROR</p>
</li>
<li><p>WARNING</p>
</li>
<li><p>INFO</p>
</li>
<li><p>DEBUG</p>
</li>
<li><p>TRACE</p>
</li>
</ul>
</blockquote>
<p><strong>使用步骤：</strong></p>
<ol>
<li>Commons Logging自动搜索并使用Log4j，其次使用JDK Logging。</li>
<li>通过LogFactory获取Log类的实例</li>
<li>使用Log实例的方法打日志    </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Log log = LogFactory.getLog(Main.class);</span><br><span class="line">log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.warn(<span class="string">&quot;end.&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>配置步骤：</strong>    </p>
<p>1.引入commonlog的jar包，将其添加到JVM的<a href="#1.11-classpath%E5%92%8Cjar">classpath</a>路径中。<br>2.包名为commons-logging-1.2.jar。<br>3.若使用命令行执行引入第三方jar包的.class文件，必须指定classpath，命令格式如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .:commons-logging-<span class="number">1</span>.<span class="number">2</span>.jar Main</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：</strong>使用<code>log.error(String, Throwable)</code>打印异常。</p>
</blockquote>
<h3 id="Log4j的使用"><a href="#Log4j的使用" class="headerlink" title="Log4j的使用"></a>Log4j的使用</h3><ul>
<li><p><strong>组件化设计架构：</strong></p>
<img src="img/image-20210817114241851.png" alt="image-20210817114241851" style="zoom:80%;" />

<ol>
<li>Appender设置日志的输出路径（控制台、文件、数据库等）</li>
<li>Filter设置过滤器，过滤日志</li>
<li>Layout设置日志信息的格式，可以使用配置文件进行设置</li>
</ol>
</li>
<li><p><strong>配置Log4j日志框架</strong></p>
<p>1.下载jar包，导入如下三个jar包：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>2.可以和Commons Logging一起使用。</p>
</li>
</ul>
<p><strong>最佳实践</strong></p>
<blockquote>
<p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p>
</blockquote>
<h1 id="六、日期与时间"><a href="#六、日期与时间" class="headerlink" title="六、日期与时间"></a>六、日期与时间</h1><h2 id="日期类型转换"><a href="#日期类型转换" class="headerlink" title="日期类型转换"></a>日期类型转换</h2><p><img src="img/%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="时间类型转换"></p>
<h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><blockquote>
<p>此类作为日期类对象，其中大部分的方法已经过时，但是，可以使用Date类来实例化日期，用作对日期的封装。</p>
<p>完全按照美国人对时间的描述而创建的类：与很多其他民族描述时间的算法都不一致    </p>
<p>缺点：</p>
<ol>
<li>它不能转换时区</li>
<li>很难对日期和时间进行加减</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Date();<span class="comment">//默认系统当前时间的对象</span></span><br><span class="line">Date(<span class="keyword">long</span> date);<span class="comment">//使用时间戳创建时间对象</span></span><br><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>;<span class="comment">//返回当前时间对象的时间戳(毫秒数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Date when)</span></span>;<span class="comment">//判断日期是否在日期之后</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Date when)</span></span>;<span class="comment">//判断日期是否在日期之前</span></span><br></pre></td></tr></table></figure>



<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><blockquote>
<p>此类作为Date类的上位替代，算是”国际化”的Date类；<br>类设计思想：为了满足国际化 提供所有时间参数 使用者自提。</p>
<p>与Date相比，主要多了一个可以做简单的日期和时间运算的功能</p>
<p>缺点：</p>
<p>不能直接使用SimpleDateformat格式化时间，需要转换成Date类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Object</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Calendar类;</span></span><br><span class="line"><span class="comment"> * 1.该类为抽象类，不能直接调用其构造方法字节实例化对象</span></span><br><span class="line"><span class="comment"> * 	 可以借助静态方法getInstance()获取其子类对象。</span></span><br><span class="line"><span class="comment"> * 2.static Calendar getInstance():获取子类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Calendar c1 = Calendar.getInstance();<span class="comment">//获取日历类实例对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法</span></span><br><span class="line"><span class="comment"> * 1.和Date相同的比较方法。</span></span><br><span class="line"><span class="comment"> * 2.设置和获取指定的时间参数：通过静态的成员变量来表示所有的时间参数 */</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> field)</span></span>;</span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 3.设置年月日：</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span>;</span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute)</span></span>;</span><br><span class="line"><span class="comment">// 4.指定时间参数添加值</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line"><span class="comment">// 5.日历和日期之间的转换</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span>;<span class="comment">//把当前日历对象的时间设置为参数日期对象定义的时间</span></span><br><span class="line"> * 		<span class="function">Date <span class="title">getTime</span><span class="params">()</span></span>;<span class="comment">//获取当前日历对象的相同时间对应的日期对象</span></span><br><span class="line"><span class="comment">// 	注：日期与日历之间的转换重要方法*</span></span><br><span class="line"> * </span><br><span class="line"><span class="comment">// 6.日历与毫秒值之间的转换</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">long</span> <span class="title">getTimeInMillis</span><span class="params">()</span></span>;<span class="comment">//获取时间戳</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">setTimeInMillis</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">// 7.清除设置时间</span></span><br><span class="line"> * 		<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"> * <span class="comment">//将此 Calendar的所有日历字段值和时间值（从历元至现在的毫秒偏移量）设置成未定义。</span></span><br><span class="line"> *</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><ul>
<li>SimpleDateFormat：日期格式化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">使用方式：</span><br><span class="line">    <span class="number">1.</span> 创建实例，调用format()方法返回格式化的字符串;</span><br><span class="line">	<span class="number">2.</span> 日期的格式只能使用构造方法传入，一经生成不可更改，除非创建新的实例;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">    <span class="number">1.</span>SimpleDateFormat();<span class="comment">//使用语言环境默认的日期格式；</span></span><br><span class="line">    <span class="number">2.</span>SimpleDateFormat(String pattern)<span class="comment">//使用给定的日期格式；</span></span><br><span class="line">     		<span class="comment">//格式例子：&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">    <span class="number">3.</span>SimpleDateFormat(String pattern,Locale locale);</span><br><span class="line">		<span class="comment">//使用给定格式和语言习惯;	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通成员方法</span></span><br><span class="line">    <span class="number">1.</span> <span class="function">String <span class="title">format</span><span class="params">(Date date)</span></span>;<span class="comment">//将日期按照内部格式化为字符串</span></span><br><span class="line">    	<span class="comment">//注：此方法为日期对象转换为字符串格式</span></span><br><span class="line">    <span class="number">2.</span> <span class="function">Date <span class="title">parse</span><span class="params">(String source)</span></span>;<span class="comment">//将符合内部日期格式的字符串转换为日期对象</span></span><br><span class="line">     	<span class="comment">/*注：1)此方法为字符串转化为日期对象的方法</span></span><br><span class="line"><span class="comment">     	  	2)此方法可能抛出异常ParseException*/</span></span><br><span class="line">    <span class="number">3.</span> <span class="function">String <span class="title">toPattern</span><span class="params">()</span></span>;<span class="comment">//返回当前日期格式化字符串;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="三、泛型"><a href="#三、泛型" class="headerlink" title="三、泛型*"></a>三、泛型*</h1><ul>
<li>jdk1.5后的新特性<br>作用：为容器的元素规范类型，<pre><code>        把容器元素类型也定义为变量，
        使用时由调用者来指定具体类型。
</code></pre>
</li>
</ul>
<h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>使用foreach遍历集合时，不能对集合元素进行删减；<br>添加会报错：ConcurrentModificationException；<br>删除则不成功；</li>
</ul>
<h2 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h2><img src="img/image-20210817181259818.png" alt="image-20210817181259818" style="zoom: 50%;" />

<p>使用集合的优势</p>
<ol start="2">
<li><p>集合支持泛型，可以限制一个集合中只能放入同一种数据类型的元素。</p>
</li>
<li><p>使用迭代器访问集合，无需知道集合内部的存储方式。（封装性好）</p>
</li>
<li><p>本质上是容器，装任意个数<strong>引用类型</strong>数据的容器</p>
</li>
<li><p>集合元素没有默认值</p>
</li>
<li><p>集合的元素只能是引用数据类型</p>
</li>
</ol>
<h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><ul>
<li>可以使会用foreach循环</li>
<li>可以使用Iterator迭代器</li>
</ul>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p><img src="img/image-20210906225744647.png" alt="image-20210906225744647"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="comment">//删除包含在c中的所有元素</span></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//判断o是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断是否为空</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//获取集合迭代器</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//是否有下一个元素</span></span><br><span class="line">	<span class="function">Object <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//将&quot;指针&quot;指向下一个元素，并返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//获取元素的个数</span></span><br><span class="line">Object[] toArray();<span class="comment">//转换为Object数组</span></span><br></pre></td></tr></table></figure>



<h2 id="List子接口"><a href="#List子接口" class="headerlink" title="List子接口"></a>List子接口</h2><blockquote>
<ol>
<li>List内部按照放入元素的先后顺序存放</li>
<li>List允许添加null,查找元素时</li>
<li>需要为放入的元素实现equals方法</li>
</ol>
</blockquote>
<blockquote>
<p>常用实现类：ArrayList、LinkList</p>
</blockquote>
<ul>
<li><p>遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法一：可以使用foreach循环遍历，底层调用Iterator迭代器;</span><br><span class="line">方法二：可以使用Interator迭代遍历集合;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><a href="#1.-equals">equals方法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际使用中可能会碰到比较对象为null的问题，所以借助Objects.equals()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">     Person p = (Person) o;</span><br><span class="line">     <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>常用方法</p>
<ul>
<li><p>add（添加元素）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E item)</span></span>;<span class="comment">//将指定项目添加到列表末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E item,<span class="keyword">int</span> index)</span></span>;<span class="comment">//添加元素到index位置。</span></span><br><span class="line"><span class="comment">/*若index&lt;0 || index&gt;size则将元素插到队尾*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> position)</span></span>;<span class="comment">//删除列表中指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(E item)</span></span>;<span class="comment">//删除指定元素，并返回被删除元素，若无则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">(Collections&lt;E&gt; c)</span></span>;<span class="comment">//删除集合内的所有元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.若position小于0或大于size，抛出数组越界异常</span></span><br><span class="line"><span class="comment">2.该方法会调用E的equals方法，所以自定义对象需要实现eqauals方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">//修改指定下标处的元素，返回旧值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 获取:</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//返回集合中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;<span class="comment">//获取元素第一次出现的下标，若元素不存在返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 判断:</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//判断列表中是否存在该元素</span></span><br><span class="line"><span class="comment">/*1.会调用传入对象的equals,方法判断是否相等*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>of（返回一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/ydonghao2/article/details/81074982">ImmutableCollections</a>类型的集合）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span></span>;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>List.of</code> 返回的是一个 <code>ImmutableCollections</code> 集合实现了 实现 <code>Iterable</code> 接口</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>数组与集合转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* toArray（转换为数组）:</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);<span class="comment">//将集合中的元素复制到指定数组，并返回</span></span><br><span class="line">	T[] array = list.toArray(T[]::<span class="keyword">new</span>);<span class="comment">//简化写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK11前</span></span><br><span class="line">Arrys.asList(T...);<span class="comment">//T...的意思是多个T类型的参数，也可以是数组</span></span><br><span class="line"><span class="comment">/*	1.该方法将数组与List链表链接起来：当更新其中一个时，另一个自动更新</span></span><br><span class="line"><span class="comment">	2.不支持add()、remove()、clear()等方法</span></span><br><span class="line"><span class="comment">	3.返回的List的长度是不可变得</span></span><br><span class="line"><span class="comment">总结：如果你的List只是用来遍历，就用Arrays.asList()。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK11后</span></span><br><span class="line">List.of(T...);<span class="comment">//返回的是一个只读List</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	对只读List调用add()、remove()方法会抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>ArrayList和LinkedList的区别</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td>较大</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>底层实现不同：ArrayList底层是可变长度数组实现的，LinkedList底层是链表</li>
<li>ArrayList元素在内存中是连续空间 而LinkedList的元素内存空间可以不连续，可以实现内容的有效利用</li>
<li>ArrayList查询和修改效率高，但增删效率低，LinkedList增删效率高，但查询和修改效率低</li>
</ol>
</blockquote>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arraylist类的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>



<h3 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h3><blockquote>
<p> LinkeList是List的实现类，底层是链表<br> 使用和Arraylist基本相同 都可以根据下标操作元素，但是提供了更多的对头和尾的操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linklis类的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>：在头部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span>：在尾部添加元素</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span>：获取头部的第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span>：获取尾部的最后一个元素</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span>：移除并返回头部的第一个元素，如果链表为空，返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span>：移除并返回尾部的最后一个元素，如果链表为空，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span>：移除并返回头部的第一个元素，如果链表为空，抛异常NoSuchElementException</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span>：移除并返回尾部的最后一个元素，如果链表为空抛异常NoSuchElementException</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：底层使用链表实现</p>
</blockquote>
<h2 id="Set子接口"><a href="#Set子接口" class="headerlink" title="Set子接口"></a>Set子接口</h2><ol>
<li><p>内部默认无序且<strong>不可重复</strong>的集合</p>
</li>
<li><p>如果只需要存储不重复的key，可以使用<code>Set</code></p>
<blockquote>
<p>常用实现类：HashSet、TreeSet</p>
</blockquote>
</li>
</ol>
<ul>
<li><p><strong>使用Set</strong></p>
<blockquote>
<p>放入<code>Set</code>的元素和<code>Map</code>的key类似，都要正确实现<code>equals()</code>和<code>hashCode()</code>方法，否则该元素无法正确地放入<code>Set</code>。</p>
</blockquote>
</li>
</ul>
<h3 id="Set不重复原理"><a href="#Set不重复原理" class="headerlink" title="Set不重复原理"></a>Set不重复原理</h3><blockquote>
<p>调用set.add(obj1)时 怎么保证元素唯一？</p>
<ol>
<li>先调用obj1的hashCode方法 获取其hashCode值</li>
<li>如果此hashCode值 与set中其他所有元素比较是唯一的<br>直接添加成功</li>
<li>如果此hashCode值 与set中其他所有元素中的n个元素 <pre><code>hashCode值相同
</code></pre>
</li>
<li>调用obj1的equals方法与这n个相同hashCode值的元素 <pre><code>分别做比较
</code></pre>
</li>
<li>只用当调用的n次equals方法都返回false 才允许添加 <pre><code>只要有一个返回true 则添加失败
</code></pre>
</li>
</ol>
</blockquote>
<p>注：可以使用hashCode先排除明显不同的对象，<br>再使用equals方法详细判断。</p>
<h3 id="Set接口常用方法"><a href="#Set接口常用方法" class="headerlink" title="Set接口常用方法"></a>Set接口常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">TreeSet(Collection&lt;? extends E&gt; c);<span class="comment">//创建有序子类TreeSet</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;<span class="comment">//将元素添加进Set&lt;E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object e)</span></span>;<span class="comment">//将元素从Set&lt;E&gt;删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object e)</span></span>;<span class="comment">//判断是否包含元素</span></span><br></pre></td></tr></table></figure>



<h3 id="Set的常用实现类"><a href="#Set的常用实现类" class="headerlink" title="Set的常用实现类"></a>Set的常用实现类</h3><ul>
<li><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：<ul>
<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>
<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>
</ul>
</li>
</ul>
<p><img src="img/image-20210818171528798.png" alt="image-20210818171528798"></p>
<ul>
<li><p>HashSet</p>
<blockquote>
<p>最常用的<code>Set</code>实现类是<code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">// 持有一个HashMap:</span></span><br><span class="line"> <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 放入HashMap的value:</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TreeSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeSet:不重复 元素按自然顺序排序</span><br><span class="line">方法：继承于Collection</span><br><span class="line">特有方法：</span><br><span class="line">	<span class="function">E <span class="title">first</span><span class="params">()</span>:获取第一个元素</span></span><br><span class="line"><span class="function">	E <span class="title">last</span><span class="params">()</span>:获取最后一个元素</span></span><br><span class="line"><span class="function">	E <span class="title">floor</span><span class="params">(E e)</span>:获取小于等于参数的最大元素，若不存在这样的元素，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">	E <span class="title">ceiling</span><span class="params">(E e)</span>:获取大于等于参数的最小元素，如果不存在这样的元素，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">	E <span class="title">higher</span><span class="params">(E e)</span>:获取大于参数的最小元素，如果不存在这样的元素，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">	E <span class="title">lower</span><span class="params">(E e)</span>:获取小于参数的最大元素，如果不存在这样的元素，则则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">	E <span class="title">pollFirst</span><span class="params">()</span>:移除并返回第一个元素</span></span><br><span class="line"><span class="function">	E <span class="title">pollLast</span><span class="params">()</span>:移除并返回最后一个元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点：</p>
<p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p>
<p>保证一个类具有可比较性：</p>
<ol>
<li><p>让类实现Comparable<E>接口，实现public int compareTo(E e) 方法</p>
</li>
<li><p>为创建一个比较器类，实现Comparator<E>,实现public int compare(E o1,E o2)</p>
<p>注意：在使用TreeSet时需要关联一个比较器对象：new TreeSet&lt;&gt;(new  Comparator());</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul>
<li><code>Map</code>存储的是<code>key-value</code>的映射关系，并且，它<em><strong>不保证顺序</strong></em></li>
<li><strong>作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）</strong></li>
<li>放入相同的key，会进行覆盖</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br><span class="line"><span class="comment">//1.若key不存在，返回null</span></span><br><span class="line"><span class="comment">//2.若key存在，返回被删除的旧的value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object Key)</span></span>;<span class="comment">//返回key对应的value，没有返回null</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;<span class="comment">//返回Key的Set集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();<span class="comment">//返回键值映射关系表</span></span><br><span class="line"><span class="comment">//该集合是由Map的支持，两者修改后会相互影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(K key)</span></span>;<span class="comment">//只是查询是否存在key值</span></span><br><span class="line"><span class="comment">//查询key值是否存在，需要实现equals</span></span><br></pre></td></tr></table></figure>



<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</p>
</li>
<li><p>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</p>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
<p>即对应两个实例<code>a</code>和<code>b</code>：</p>
<ul>
<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>
<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ul>
<ul>
<li><p>HashMap</p>
<blockquote>
<ol>
<li>键和值都可以为null，但是treeMap都不可为null。</li>
</ol>
</blockquote>
</li>
<li><p>TreeMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*	注意到Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，</span></span><br><span class="line"><span class="comment">如果a&lt;b，则返回负数，通常是-1，如果a==b，则返回0，如果a&gt;b，则返回正数，通常是1。</span></span><br><span class="line"><span class="comment">TreeMap内部根据比较结果对Key进行排序	*/</span> </span><br><span class="line">Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序Map</p>
<ul>
<li>HashMap内部存储使用hash函数设置索引，其顺序不可预测。</li>
<li>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<a href="#SortedMap"><code>SortedMap</code></a>。</li>
</ul>
</blockquote>
</li>
<li><p>EnumMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节省空间Map</span></span><br><span class="line">Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
</blockquote>
</li>
</ul>
<ul>
<li>SortedMap<ol>
<li><code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</li>
<li><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。</li>
<li><code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</li>
<li>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口<br>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法</li>
</ol>
</li>
</ul>
<h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>编译器把for each循环使用Iterator遍历集合，这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器</p>
<ul>
<li><p>使用迭代器的好处：</p>
<ul>
<li><p>对任何集合都采用同一种访问模型；</p>
</li>
<li><p>调用者对集合内部结构一无所知；</p>
</li>
<li><p>集合类返回的<code>Iterator</code>对象知道如何迭代。</p>
<blockquote>
<ol>
<li><p>调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构</p>
</li>
<li><p>Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Iterator</code>对象是集合对象的内部类，它自己知道如何高效遍历内部的数据集合</p>
</li>
</ul>
<h3 id="改写Iterator"><a href="#改写Iterator" class="headerlink" title="改写Iterator"></a>改写Iterator</h3><ul>
<li><p>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</p>
</li>
<li><p>用<code>Iterator</code>对象迭代集合内部数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Iterator内部类，返回一个iterator类用于遍历该集合</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例。</p>
</li>
<li><p>调用方则完全按<code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h3><h1 id="五、IO流"><a href="#五、IO流" class="headerlink" title="五、IO流"></a>五、IO流</h1><img src="https://img-blog.csdnimg.cn/20200326152513637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjkyNDgxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"  />

<ul>
<li><p>字符集</p>
<blockquote>
<p>在进行文件输出时，尤其是文本流，需要设置字符集，例如：utf-8<br>当两者的字符集不匹配时，会发生乱码</p>
</blockquote>
</li>
<li><p>序列化</p>
<blockquote>
<p>将对象从内存输出到外存时，需要将对象序列列化，否则会报错。<br>序列化的目的是为了输出和输入的数据一致而设置的”秘钥“。</p>
</blockquote>
</li>
</ul>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中提供的用于文件操作的实体类 java.IO.File;</span></span><br><span class="line">--文件地址分隔符--</span><br><span class="line"><span class="keyword">static</span> String separator:<span class="comment">//File.separator</span></span><br><span class="line"></span><br><span class="line">--构造方法--</span><br><span class="line">File(String parent,String child);<span class="comment">//可用于文件的复制或者剪切</span></span><br><span class="line">File(String pathname);</span><br><span class="line"></span><br><span class="line">--普通方法--</span><br><span class="line"><span class="comment">// 获取文件名字</span></span><br><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> :获取绝对路径</span>;</span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span> :获取创建对象时 构造方法的参数</span>;</span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> :获取文件/文件夹名字 不带父目录</span>;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> :判断是否存在</span>;</span><br><span class="line"><span class="function">Boolean <span class="title">isDirectory</span><span class="params">()</span> :判断是否为目录 文件必须存在</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> :判断是否为文件 文件必须存在</span>;</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> :只能创建文件/不能创建文件夹，存在返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> :只能创建一层目录，存在返回fasle</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> :可以创建多层目录</span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOnExit</span><span class="params">()</span>：程序结束前删除</span>;<span class="comment">//文件夹需要是空的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>：删除文件/文件夹，但删除文件夹时，文件必须是空的</span></span><br><span class="line"><span class="function"><span class="comment">// 获取</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> :获取文件字节数 不能获取文件夹</span></span><br><span class="line"><span class="function">File <span class="title">getParentFile</span><span class="params">()</span> :获取直接父目录</span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span> :获取直接父目录的路径</span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span> :获取当前目录下的所有直接子文件/子文件夹</span></span><br><span class="line"><span class="function"><span class="comment">// 重命名</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span> :文件重命名，重名则返回<span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>



<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul>
<li><p>按方向分类(输入流/输出流)</p>
<blockquote>
<p>输入：从程序外部调入到程序内部，称为InputStream/Reader<br>输出：从程序内部调出到程序外部，称为OutputStream/Writer</p>
</blockquote>
</li>
<li><p>按基本单位分类(字节流/字符流)</p>
<blockquote>
<p>字节流：操作的基本单位是字节，后缀为Stream<br>字符流：操作的基本单位是字符对应的字节集合，后缀为Reader/Writer</p>
</blockquote>
</li>
<li><p>按关联对象分类<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88233122">(节点流/处理流)</a></p>
<blockquote>
<p>节点流：从一个特定的地方（节点）读写数据。如FileReader</p>
<p>装饰流/过滤流：对一个已存在的流进行功能加强/增加，</p>
<pre><code>                        (相当于一种流的代理类)如：InputStream
</code></pre>
</blockquote>
</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><blockquote>
<p>abstract  class  InputStream：字节输入流的顶层父类<br>abstract  class  OutputStream：字节输出流的顶层父类</p>
</blockquote>
<p>子类FileInputStream/子类FileOutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--输入流--</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileInputStream(File file);</span><br><span class="line">FileInputStream(String name); </span><br><span class="line">普通方法</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//一次一个字节 文件末尾返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;<span class="comment">//读取全部的字节数组 文件末尾-1 返回值是本次读到的有效字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;<span class="comment">//读一个字节数组的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭流</span></span><br><span class="line"></span><br><span class="line">--输出流--</span><br><span class="line">构造方法: 若目标文件不存在，则自动创建文件；若目标文件存在，则覆写目标文件;</span><br><span class="line">FileOutputStream(File file);</span><br><span class="line">FileOutputStream(String name);</span><br><span class="line">FileOutputStream(File file,<span class="keyword">boolean</span> append);<span class="comment">// 实现文件的续写</span></span><br><span class="line">FileOutputStream(String name,<span class="keyword">boolean</span> append);</span><br><span class="line"></span><br><span class="line">普通方法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span>;		<span class="comment">// 一次写一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;	<span class="comment">// 一次写出一个字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;<span class="comment">// 一次写出一个字节数组的一部分</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">字符流：每次操作的最小单位是一个字符对应的字节数组</span><br><span class="line">顶层父类：Reader + Writer</span><br><span class="line">子类：FileReader + FileWriter</span><br><span class="line"></span><br><span class="line">字符输入流</span><br><span class="line">构造方法：</span><br><span class="line">FileReader(File file) </span><br><span class="line">FileReader(String fileName)  </span><br><span class="line">普通方法：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>  :一次写一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>：一次写一个字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf,<span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>：一次写一个字符数组的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>：关闭流 释放资源</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">字符输出流</span></span><br><span class="line"><span class="function">构造方法：若文件不存在，则创建文件；若无法创建，则抛出异常IOException</span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(File file)</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(String fileName)</span> </span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(String fileName, <span class="keyword">boolean</span> append)</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">普通方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>：关闭流 释放资源 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">String <span class="title">getEncoding</span><span class="params">()</span>：获取字符编码集</span></span><br></pre></td></tr></table></figure>



<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">转换路：把字节流转换为字符流</span><br><span class="line">实现类：InputStreamReader/OutputStreamWriter</span><br><span class="line">公共方法：<span class="function">String <span class="title">getEncoding</span><span class="params">()</span></span>;<span class="comment">//获取编码集  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流：</span></span><br><span class="line">构造方法：</span><br><span class="line">OutputStreamWriter(OutpurSteam out, String charsetName);</span><br><span class="line"><span class="comment">//	不加字符集，使用默认字符集</span></span><br><span class="line">普通方法：和FileWriter完全相同</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入流:</span></span><br><span class="line">构造方法：</span><br><span class="line">InputStreamReader(InputStream in, String charsetName);</span><br><span class="line"><span class="comment">//	和输出流的相似</span></span><br><span class="line">普通方法：和FileReader完全相同</span><br></pre></td></tr></table></figure>



<h2 id="高效流"><a href="#高效流" class="headerlink" title="高效流"></a>高效流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高效流：过滤流的一种	作用：增加节点流的传输效率</span></span><br><span class="line"><span class="comment">//实现类：</span></span><br><span class="line">	BufferedInputStream/BufferedOutputStream</span><br><span class="line">	BufferedReader/BufferedWriter</span><br><span class="line"><span class="comment">//关键字：</span></span><br><span class="line">	流的名字中带有 Buffered 字样的，皆为高效流;</span><br><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">	该流为修饰流，所以在创建时，需要传入其他(节点)流作为关联;</span><br><span class="line">	例：BufferedInputStream(InputStream in);</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">	被此流修饰过后，除了在传输效率上有所提高外，</span><br><span class="line">	使用上和修饰前使用方式基本相同相同，个别功能会有所增加。</span><br><span class="line">BufferedReader特有方法：<span class="function">String <span class="title">readLine</span><span class="params">()</span></span>;<span class="comment">//支持逐行读,到达末尾,返回null</span></span><br><span class="line">BufferedWriter特有方法：<span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span></span>;<span class="comment">//写一个换行符</span></span><br></pre></td></tr></table></figure>



<h2 id="打印输出流"><a href="#打印输出流" class="headerlink" title="打印输出流"></a>打印输出流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter打印流</span><br><span class="line"> 	特点<span class="number">1</span>：既可以是节点流，也可以是过滤流</span><br><span class="line"> 		 PrintWriter(File file)</span><br><span class="line"> 		 PrintWriter(OutputStream out)</span><br><span class="line"> 	特点<span class="number">2</span>：可以保证数据的原始状态</span><br><span class="line"> 		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="number">49</span>)</span></span>;	等价于print(<span class="number">49</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line"> 	特点<span class="number">3</span>：当创建对象时指定自动刷新 调用println是可以实现自动刷新</span><br></pre></td></tr></table></figure>



<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*序列化相关的类：把内存中对象的信息持久保存到硬盘中，</span></span><br><span class="line"><span class="comment">  把硬盘的信息重构成内存中的的对象</span></span><br><span class="line"><span class="comment">  对象在内存中是字节，所以是字节流。*/</span></span><br><span class="line"> </span><br><span class="line"> ObjectInputStream：反序列化，把硬盘中的信息读到内存中 重构成对象</span><br><span class="line"> ObjectOutputStream：序列化流，把内存中对象的信息持久化保存到硬盘上</span><br><span class="line"> 		</span><br><span class="line"><span class="comment">// ObjectOutputStream的方法：</span></span><br><span class="line"> 		ObjectOutputStream(OutputStream out) ：构造方法关联一个字节流</span><br><span class="line"> 		<span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span>	：把一个对象的信息写到目的文件中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ObjectInputStream的方法：</span></span></span><br><span class="line"><span class="function"> 		<span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span>	：构造方法关联一个字节流</span></span><br><span class="line"><span class="function"> 		Object <span class="title">readObject</span><span class="params">()</span>	：一次读一个对象的信息 并重构对象</span></span><br><span class="line"><span class="function"> 	</span></span><br><span class="line"><span class="function"><span class="comment">// 注意事项：</span></span></span><br><span class="line"><span class="function"> 		1 序列化流和反序列化流 操作的兑现必须实现接口Serializable</span></span><br><span class="line"><span class="function"> 		2 ObjectInputSteam的<span class="title">readObjec</span><span class="params">()</span>方法读到文件末尾会抛出EOFException。</span></span><br><span class="line"><span class="function"> 		3 Serializable接口会给当前类分配一个唯一的编号，用于保证序列化和反序列化使用的同一个接口</span></span><br><span class="line"><span class="function"> 		4 序列化流不支持续写</span></span><br><span class="line"><span class="function"><span class="comment">// UUID:通用唯一识别码</span></span></span><br><span class="line"><span class="function"> 		随机一个32为的16进制的整型变量</span></span><br></pre></td></tr></table></figure>



<h1 id="六、线程"><a href="#六、线程" class="headerlink" title="六、线程"></a>六、线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//概念：</span></span><br><span class="line">	在电脑中，一个程序可以看做一个进程，线程可以看做是进程的缩小版,</span><br><span class="line">	进程是运行的工厂，线程就是工厂的流水线；</span><br><span class="line"><span class="comment">//多线程/并发：</span></span><br><span class="line">	同一个进程中有多个线程在同时执行，程序中需要多个代码块同时执行--需要多线程。</span><br><span class="line"><span class="comment">//多线程执行原理：</span></span><br><span class="line">	cpu在时间轮片内在多个线程之间随机切换。</span><br></pre></td></tr></table></figure>

<ul>
<li>垃圾回收机制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. jvm会不定时的启动垃圾回收器对象  </span><br><span class="line">	垃圾回收器对象会根据创建的对象是否存在更多引用</span><br><span class="line">	来判断对象是否是垃圾</span><br><span class="line">2. 如果是垃圾就调用此对象的finalize方法，来销毁对象释放内存</span><br><span class="line">3. 程序员通过调用System.gc()方法来运行垃圾回收器对象</span><br><span class="line">	来干涉垃圾回收机制</span><br><span class="line">4. 垃圾回收有一个单独的线程 和main线程不是同一个线程</span><br></pre></td></tr></table></figure>



<h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt="线程状态转换" style="zoom: 67%;" />

<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xingjing1226/article/details/81977129">线程的5中状态</a></p>
</li>
<li><p>继承<a href="#Thread">Thread</a>类，重写run方法</p>
</li>
<li><p>实现<a href="#Runnable">Runnable</a>接口， 实现run方法</p>
<blockquote>
<p>JDK1.5 以后新增了以下两种创建方式</p>
</blockquote>
</li>
<li><p>实现<a target="_blank" rel="noopener" href="https://www.cnblogs.com/flower-dance/p/13740315.html">Callable</a>接口</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34562093/article/details/90209520">Future.get()</a>方法的理解</li>
</ul>
</li>
<li><p>使用线程池创建线程</p>
</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* Thread：线程类</span><br><span class="line">	 * 构造方法：</span><br><span class="line">	 *   Thread() </span><br><span class="line">		 Thread(Runnable target) </span><br><span class="line">		 Thread(Runnable target, String name) </span><br><span class="line">		 Thread(String name) </span><br><span class="line">     * 普通方法：</span><br><span class="line">	 *   <span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>   ：获取当前线程对象</span></span><br><span class="line"><span class="function">	 *   String <span class="title">getName</span><span class="params">()</span>                ：获取线程对象的名字</span></span><br><span class="line"><span class="function">	 *   <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span>       ：设置线程对象的名字</span></span><br><span class="line"><span class="function">	 *   <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>                     ：线程等待</span></span><br><span class="line"><span class="function">	 *   <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>                      ：执行线程任务    </span></span><br><span class="line"><span class="function">	 *   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span>  ：线程休眠</span></span><br><span class="line"><span class="function">	 *   <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>                    ：启动线程</span></span><br><span class="line"><span class="function">     线程任务：线程中关联的代码块</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     创建线程的方式1：继承Thread类 重写run方法</span></span><br><span class="line"><span class="function">         1）将类声明为 Thread 的子类。</span></span><br><span class="line"><span class="function">         2）该子类应重写 Thread 类的 run 方法。</span></span><br><span class="line"><span class="function">         3）接下来可以分配实例</span></span><br><span class="line"><span class="function">         4）并启动该子类的实例</span></span><br></pre></td></tr></table></figure>



<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Runnable是一个接口，其中包括了线程的核心方法run()</span><br><span class="line">如果只是想使用run方法，则无需创建线程子类。</span><br><span class="line">作用：</span><br><span class="line">	<span class="number">1.</span>使用Runable实现run方法可以实现更好的封装。</span><br><span class="line">	<span class="number">2.</span>使用接口实现更加易于扩展</span><br><span class="line"></span><br><span class="line">创建线程的方式<span class="number">2</span>：继承Runnable接口 实现run方法</span><br><span class="line">    	 <span class="number">1</span>）创建一个类实现Runnable接口</span><br><span class="line">    	 <span class="number">2</span>）实现run方法：封装的线程任务</span><br><span class="line">    	 <span class="number">3</span>）创建实现类的对象</span><br><span class="line">    	 <span class="number">4</span>）创建Thread对象 并通过构造方法参数列表来关联实现类</span><br><span class="line">    	 <span class="number">5</span>）开启线程</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;&#125;,String name);</span><br><span class="line"><span class="comment">//使用Thread的构造方法创建线程</span></span><br></pre></td></tr></table></figure>



<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Callable接口和Runnable接口类似，</span><br><span class="line">就像是用于封装线程的执行任务的类。</span><br><span class="line">区别：</span><br><span class="line"><span class="number">1.</span> Runnable接口重写run方法，没有返回值，不能抛出异常，</span><br><span class="line">	Callable接口的call方法，有返回值(使用了泛型)，可以抛出异常。</span><br><span class="line"><span class="number">2.</span> Runnable可以直接作为构造参数，用于创建线程，而Callable不可以。</span><br><span class="line">	Callable的使用，需要FutureTask实现类，用于接收运算结果。</span><br><span class="line"></span><br><span class="line">FutureTask类实现类Runnable接口，可以将其作为Runnable类型的参数</span><br><span class="line">传递给Thread的构造方法，用于创建新的线程。</span><br><span class="line"></span><br><span class="line">使用步骤：</span><br><span class="line"><span class="comment">//1 继承Callable接口，实现call方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        retrun ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 实例化实现类，用于创建FutureTask实例</span></span><br><span class="line">	FutureTask&lt;String&gt; ft = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyCall());</span><br><span class="line"><span class="comment">//3 实例化线程，将FutureTask线程绑定到线程中开始执行</span></span><br><span class="line">	Thread t1 = <span class="keyword">new</span> Thread(ft);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Callable的使用类似于将一个函数，交给另一个线程执行，</span></span><br><span class="line"><span class="comment">主线程继续执行别的函数，当Callable的线程将执行结果返回后，</span></span><br><span class="line"><span class="comment">加入到主线程中继续执行，</span></span><br><span class="line"><span class="comment">相当于执行的时间大于等于执行时间最长的函数，</span></span><br><span class="line"><span class="comment">在未调用get方法获取call的返回值时，程序可以继续执行</span></span><br><span class="line"><span class="comment">get方法是阻塞方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">若call所在线程执行完毕，则可以直接获取到值，不会影响到主线进度；</span></span><br><span class="line"><span class="comment">若call所在线程未执行完毕，则会在get方法处阻塞，直到获取到call的返回值；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">4</span>：线程池：线程提供了一个线程队列，队列中保存着所有等待状态的线程，</span><br><span class="line">		避免了创建与销毁额外开销，提高了响应速度。</span><br><span class="line">具体步骤：</span><br><span class="line"><span class="comment">//1 创建Runnable的实现类 通过Executors创建线程池对象，</span></span><br><span class="line">	通过池对象的submit方法来启动一个线程</span><br><span class="line"><span class="comment">//2 创建线程池对象，并制定线程个数</span></span><br><span class="line">	ExecutorsService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//3 创建实现类对象</span></span><br><span class="line">	MyImp04 imp = <span class="keyword">new</span> MyImp04();</span><br><span class="line"><span class="comment">//5 通过线程池对象的submit方法，提交线程任务，提交的次数就是运行的线程个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		threadPool.submit(imp);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//6 关闭池对象</span></span><br><span class="line">	threadPool.shutdown();</span><br></pre></td></tr></table></figure>



<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">多个线程同时操作一个共享数据时，当一个线程在使用数据时，另一个线程对数据进行了修改</span><br><span class="line">导致与所期望的执行结果不同。</span><br><span class="line"></span><br><span class="line"><span class="comment">//造成问题的条件：</span></span><br><span class="line"><span class="number">1.</span>多线程 <span class="number">2.</span>有共享数据 <span class="number">3.</span>多个语句操作共享数据</span><br><span class="line"><span class="comment">//造成问题的原因：</span></span><br><span class="line"><span class="number">1.</span>线程的执行顺序无法预测</span><br><span class="line"><span class="comment">//解决问题的方法：(线程)</span></span><br><span class="line"><span class="number">1.</span>使用<span class="keyword">synchronized</span>关键字，为执行代码块上锁，</span><br><span class="line">	使得同一时刻，共享数据只能被单个线程访问。</span><br></pre></td></tr></table></figure>



<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>synchronized</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法：将共享数据作为锁，来为指定代码块上锁</span></span><br><span class="line"><span class="comment">//作用：只有持有锁(对象)，才可以执行内部的代码块，相当于访问权限限制</span></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">synchronized</span>(Obj 锁对象)&#123;</span><br><span class="line">	锁内代码块;</span><br><span class="line">&#125;<span class="comment">//结尾处，可以看做释放锁</span></span><br><span class="line">通过上述方法，可以将所内代码块变为原子操作，即不可分割执行的代码。</span><br><span class="line">要么，不执行；要么，一口气执行完。</span><br></pre></td></tr></table></figure>

<ul>
<li>同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个方法的方法体要求同步时，可以定义该方法为同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步方法的锁是当前对象，即this</span></span><br></pre></td></tr></table></figure>

<ul>
<li>wait和notify</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 面试题：wait和sleep的区别</span></span><br><span class="line"><span class="comment"> wait和notify都是锁对象的方法</span></span><br><span class="line"><span class="comment"> Object类的方法： void wait()    当前线程等待</span></span><br><span class="line"><span class="comment"> Object类的方法： void notify()  随机唤醒一个当前对象作为锁对象 并且处于等待状态的线程</span></span><br><span class="line"><span class="comment"> Object类的方法： void notifyAll()  唤醒所有当前对象作为锁对象 并且处于等待状态的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同之处：</span></span><br><span class="line">两者都会使线程进入阻塞状态。</span><br><span class="line"></span><br><span class="line"><span class="comment">//wait方法：</span></span><br><span class="line"><span class="number">1.</span> wait是Object方法的方法，</span><br><span class="line"><span class="number">2.</span> 只能在同步代码块使用，</span><br><span class="line"><span class="number">3.</span> 失去时间片的获取权限，</span><br><span class="line"><span class="number">4.</span> 会释放同步代码块的锁，</span><br><span class="line"><span class="number">5.</span> 只能被其他人唤醒，不能被自己唤醒</span><br><span class="line"><span class="comment">//sleep方法：</span></span><br><span class="line"><span class="number">1.</span> sleep是Thread的方法，</span><br><span class="line"><span class="number">2.</span> 必须指定时间参数,</span><br><span class="line"><span class="number">3.</span> 不会失去时间片获取权限，</span><br><span class="line"><span class="number">4.</span> 时间到期后会自动唤醒。</span><br><span class="line"><span class="comment">//jion方法：</span></span><br><span class="line"><span class="number">1.</span> 会使当前线程进入阻塞，直到jion调用的线程完成为止。</span><br><span class="line"><span class="number">2.</span> 不会释放锁</span><br><span class="line">    </span><br><span class="line">sleep的实际含义是该代码需要的执行时间，</span><br><span class="line">也就是说等效于执行该时间长度的代码块，</span><br><span class="line">会占用使用时间片的时间。</span><br><span class="line">sleep(<span class="number">100</span>);<span class="comment">//一段需要执行100毫秒的代码块</span></span><br></pre></td></tr></table></figure>



<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁*"></a>死锁*</h2><p>死锁是多线程编程中常见的一种问题，该问题的出现是由线程执行的不确定性造成的。</p>
<p>线程可以看做进程的子进程，在执行期间的顺序不可预测，也就是抢占式线程，<br>谁抢到时间片就执行谁，其中充满了不确定性。</p>
<p>死锁的实例：</p>
<ul>
<li><p>死锁现象1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用jion产生的死锁现象</span><br><span class="line">原理：两个线程中，相互调用对方线程的jion方法，互相等待对方执行结束，产生死锁。</span><br><span class="line">//使用synchronized关键字，对代码块上锁，实现线程同步</span><br><span class="line">原理：执行代码块需要的资源不唯一，需要对多个资源进行上锁，但是一次拿不完，</span><br><span class="line">	多个线程抢到部分资源，但是因为资源不全，无法执行后续代码，但是不释放资源，</span><br><span class="line">	相互等待对方释放资源，从而进入无限等待的状态。</span><br><span class="line">造成原因：持有抢占？</span><br><span class="line">示例1：</span><br><span class="line">//jion实现死锁</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="七、网络编程"><a href="#七、网络编程" class="headerlink" title="七、网络编程"></a>七、网络编程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>实现网络中，不同电脑之间的数据传输</p>
</blockquote>
<ul>
<li><p>Ip地址(Internet Protocol Address)是指互联网络协议地址</p>
<ul>
<li><p>IPV4：4个1个byte的十进制数字</p>
</li>
<li><p>IPV6：8个2个byte的16进制数字</p>
<p>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，一次来屏蔽物理地址的差异。<br>一个字符串用于唯一标识互联网上主机</p>
</li>
<li><p>127.0.0.1/localhost  表示本地主机</p>
</li>
</ul>
</li>
<li><p>域名：ip地址不易于记忆 通过一段字符串来和ip地址一一对应</p>
</li>
<li><p>域名服务器：DNS 解析域名与ip的对应关系</p>
</li>
<li><p>PORT：端口  逻辑端口  电脑上安装的所有软件都会分配一个唯一的编号</p>
<pre><code>          0-65535 实现互联网数据传输
          注意10000以下的端口 不要使用  默认被操作系统的软件使用
</code></pre>
</li>
</ul>
<h2 id="Socket分类"><a href="#Socket分类" class="headerlink" title="Socket分类"></a>Socket分类</h2><ul>
<li><p>TCP：Transmission Control Protocol</p>
<pre><code>可控的、端对端的、字节流传输协议
</code></pre>
<p>类似于：打固定电话</p>
</li>
<li><p>UDP：User Datagram Protocol   用户数据报协议</p>
<pre><code>        不可靠的、无需链接的、报文流传输协议
</code></pre>
<p>类似于：发电报</p>
</li>
</ul>
<h2 id="套接字TCP"><a href="#套接字TCP" class="headerlink" title="套接字TCP"></a>套接字TCP</h2><p>tcp的两端：客户端和服务器端<br>主动接电话的——服务器端<br>主动打电话的——客户端<br>主要涉及的类：ServiceSocket、Socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;<span class="comment">//属于net包需要添加引用</span></span><br><span class="line"></span><br><span class="line">ServerSocket:服务器套接字</span><br><span class="line">	  构造方法：ServerSocket(<span class="keyword">int</span> port) 	:开启服务并指定端口</span><br><span class="line">	  普通方法：<span class="function">Socket <span class="title">accept</span><span class="params">()</span> 			:等到和获取客户端连接</span></span><br><span class="line"><span class="function">	  		     <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 		   :关闭服务</span></span><br><span class="line"><span class="function">	  			</span></span><br><span class="line"><span class="function">Socket：套接字/传输通道</span></span><br><span class="line"><span class="function">	  构造方法:<span class="title">Socket</span><span class="params">(String host,<span class="keyword">int</span> port)</span>	创建连接 并制定服务器端的ip和port</span></span><br><span class="line"><span class="function">	  普通方法：InputStream <span class="title">getInputStream</span><span class="params">()</span> 	:获取输入流</span></span><br><span class="line"><span class="function">	  		OutputStream <span class="title">getOutputStream</span><span class="params">()</span> 	:获取输出流</span></span><br><span class="line"><span class="function">	  		<span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 					:关闭socket</span></span><br><span class="line"><span class="function">	  		InetAddress <span class="title">getInetAddtess</span><span class="params">()</span>	获取自己的ip</span></span><br><span class="line"><span class="function">	  		InetAddrss <span class="title">getLocalAddress</span><span class="params">()</span>	获取对方的ip</span></span><br><span class="line"><span class="function">	  		<span class="keyword">int</span> <span class="title">getLocalPort</span><span class="params">()</span>				获取自己的端口</span></span><br><span class="line"><span class="function">	  		<span class="keyword">int</span> <span class="title">fetPort</span><span class="params">()</span>					获取对方的端口	</span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">ServerSocket使用步骤：</span></span><br><span class="line"><span class="function"><span class="comment">//1 开启服务：创建一个ServerSocket并开启一个端口</span></span></span><br><span class="line"><span class="function">ServerSocket server </span>= <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</span><br><span class="line"><span class="comment">//2 等待客户端的连接</span></span><br><span class="line">Socket socket=server.accept();<span class="comment">//阻塞方法</span></span><br><span class="line"><span class="comment">//3 获取socket的输入流和输出流 用于接受和发送信息</span></span><br><span class="line">InputStream in=socket.getInputStream();</span><br><span class="line">OutputStream out=socket.getOutputStream();</span><br><span class="line"><span class="comment">//4 接收和发送信息</span></span><br><span class="line">...可自由发挥部分...</span><br><span class="line">前后都是固定步骤，记住即可，该部分为核心逻辑，</span><br><span class="line">可以理解为前后都是声明，该部分为方法体</span><br><span class="line"><span class="comment">//5 关闭服务</span></span><br><span class="line">server.close();</span><br><span class="line"></span><br><span class="line">Socket使用步骤：</span><br><span class="line"><span class="comment">//1 创建socket 指定服务器端的ip和port</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.118.133&quot;</span>,<span class="number">10086</span>);</span><br><span class="line"><span class="comment">//2 获取输入流和输出流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">//3 发送和接收数据</span></span><br><span class="line">...同ServerSocket内容基本相同...</span><br><span class="line">注：发送和接收顺序相反</span><br><span class="line"><span class="comment">//关闭客户端</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用时，注意一般先开启ServerSocket再开启Socket</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/timetellu/p/11625924.html">实现文件上传</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在问题：</span></span><br><span class="line">　　服务端和客户端都会陷入阻塞状态，原因是客户端的read()方法引起的。</span><br><span class="line">　　客户端的本地输入流bis.read(b))一直阻塞，读取不到-<span class="number">1</span>，其网络输出流也就输出不了-<span class="number">1</span>；这样服务端的网络输入流也就读不到-<span class="number">1</span>，进入阻塞，一直死循环等待结束标记。</span><br><span class="line"><span class="comment">//解决办法：</span></span><br><span class="line">　　客户端上传完文件，给服务器写一个结束标记。使用socket.shotdownOutput()方法，</span><br><span class="line">　　但方面断开流，就可以使得服务端可以接收到-<span class="number">1.</span></span><br><span class="line"><span class="comment">//特别注意：</span></span><br><span class="line">	使用该方法断开连接后，客户端仍可以接收数据，服务端仍可以发送数据。</span><br><span class="line">	</span><br><span class="line"><span class="comment">//client端核心代码</span></span><br><span class="line"><span class="keyword">while</span>((n=bin.read(arr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	out.write(arr, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭socket的输出流</span></span><br><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure>









<h2 id="套接字UDP"><a href="#套接字UDP" class="headerlink" title="套接字UDP"></a>套接字UDP</h2><p>UDP：报文流传输协议，传输时使用的是字节流</p>
<p>主要类：DatagramPacket+DatagramSocket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">InetAddress;<span class="comment">//该类为java封装的ip地址类，可以使用该类的静态方法获取ip地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getByName</span><span class="params">(String host)</span></span>;<span class="comment">//已知主机名获取ip地址</span></span><br><span class="line"></span><br><span class="line">DatagramPacket;<span class="comment">//对发送和接收的信息的封装</span></span><br><span class="line">构造方法:</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length);<span class="comment">//用于接收的报文</span></span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length,InetAddress address,<span class="keyword">int</span> port);<span class="comment">//用于发送的报文</span></span><br><span class="line">普通方法：</span><br><span class="line"><span class="function">InetAddress <span class="title">getAddress</span><span class="params">()</span>:获取对方的ip</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span>		:获取对方的ip</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">getData</span><span class="params">()</span></span>;<span class="comment">//获取包含数据的字节数组	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*获取数据的长度，当没有接收数据时，获取的是设置的长度，</span></span><br><span class="line"><span class="comment">当接收数据后，获取的是接受数据的长度，当接收数据大于设置的容器时，</span></span><br><span class="line"><span class="comment">会丢失超出长度的部分*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> iport)</span> <span class="comment">//设置要将此数据报发往的远程主机上的端口号。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSocketAddress</span><span class="params">(SocketAddress address)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置要将此数据报发往的远程主机的 SocketAddress（通常为 IP 地址 + 端口号）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DatagramSocket:报文流的套接字</span></span><br><span class="line"><span class="function">构造方法：</span></span><br><span class="line"><span class="function"><span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port)</span>		:<span class="comment">//指定开启的打开，并绑定到本机上</span></span></span><br><span class="line"><span class="function"><span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port, InetAddress laddr)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//创建数据报套接字，将其绑定到指定的本地地址</span></span></span><br><span class="line"><span class="function">普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span>	:<span class="comment">//接收报文对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span>		:<span class="comment">//发送报文</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> :<span class="comment">//关闭套接字</span></span></span><br><span class="line"><span class="function">InetAddress <span class="title">getLocalAddress</span><span class="params">()</span>	:<span class="comment">//获取本地的ip</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLocalPort</span><span class="params">()</span>				:<span class="comment">//获取本地的port</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//使用步骤：</span></span></span><br><span class="line"><span class="function">发送方：</span></span><br><span class="line"><span class="function"><span class="comment">//1 创建datagramsocket</span></span></span><br><span class="line"><span class="function">DatagramSocket socket</span>=<span class="keyword">new</span> DatagramSocket(<span class="number">10086</span>);</span><br><span class="line"><span class="comment">//2 创建一个datagrampacket，用于封装发送信息</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(arr, arr.length,</span><br><span class="line">InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10010</span>);</span><br><span class="line"><span class="comment">//3 发送信息</span></span><br><span class="line">socket.send(packet);</span><br><span class="line"><span class="comment">//4 关闭socket</span></span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line">接收方：</span><br><span class="line"><span class="comment">//1 创建socket</span></span><br><span class="line">DatagramSocket scoket=<span class="keyword">new</span> DatagramSocket(<span class="number">10010</span>);</span><br><span class="line"><span class="comment">//2 创建一个空的datagramepacket用于接受信息</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line"><span class="comment">//3 接受信息</span></span><br><span class="line">scoket.receive(packet);</span><br><span class="line"><span class="comment">//4 解析信息</span></span><br><span class="line">String message=<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line"><span class="comment">//5 关闭socket</span></span><br><span class="line">scoket.close();</span><br><span class="line"></span><br><span class="line">概括使用步骤：</span><br><span class="line">    首先关键步骤在第<span class="number">2</span>步：</span><br><span class="line">    <span class="number">1.</span> 发送方在该步骤可以将需要发送的信息进行处理，装入DatagramPacket对象中；</span><br><span class="line">    	该对象中除了发送的信息外，还要包括目标的ip地址和端口号</span><br><span class="line">    	使用 send(DatagramPacket packet) 方法将对象发送出去。</span><br><span class="line">    <span class="number">2.</span> 接收方同样需要创建一个DatagramPacket的对象作为容器，用来接收数据；</span><br><span class="line">    	但是因为不知道接收数据的实际大小，容器可能装不下，猜测会发生错误！</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. DatagramPacket packet=new DatagramPacket(byte[] buf, int length);</span><br><span class="line">	DatagramPacket的getLenth()的方法返回数据的长度，</span><br><span class="line">	若是没有使用receive()接收过数据，则返回构造方法时传入的长度参数length;</span><br><span class="line">	若是使用receive()接收过数据，则返回接收到的数组的实际长度。</span><br><span class="line">2. UDP的信息发送和接收是没有建立稳定连接的，所以单方面发送和单方面接收信息时，</span><br><span class="line">	可能会出现速度不同，即发送方已经发完了，但是接收方还在等待，</span><br><span class="line">	----归结为线程的不同步问题。</span><br></pre></td></tr></table></figure>



<h1 id="八、设计模式"><a href="#八、设计模式" class="headerlink" title="八、设计模式"></a>八、设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote>
<p>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 结构性模式</span><br><span class="line"></span><br><span class="line">&gt; 把类或对象结合在一起形成一个更大的结构。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 行为型模式</span><br><span class="line"></span><br><span class="line">&gt;类和对象如何交互，及划分责任和算法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>


---

三、反射*

四、注解*

八、正则表达式

十、函数式编程
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="方方">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="月曜日的丰满">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/02/hello-world/" class="post-title-link" itemprop="url">hello world</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-02 15:56:45" itemprop="dateCreated datePublished" datetime="2021-11-02T15:56:45+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-03 16:01:28" itemprop="dateModified" datetime="2021-11-03T16:01:28+08:00">2021-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">方方</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">方方</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
